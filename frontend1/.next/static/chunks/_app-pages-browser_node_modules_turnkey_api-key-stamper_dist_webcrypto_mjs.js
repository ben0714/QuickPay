"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_turnkey_api-key-stamper_dist_webcrypto_mjs"],{

/***/ "(app-pages-browser)/./node_modules/@turnkey/api-key-stamper/dist/tink/bytes.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@turnkey/api-key-stamper/dist/tink/bytes.mjs ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromHex: function() { return /* binding */ fromHex; },\n/* harmony export */   toBase64: function() { return /* binding */ toBase64; },\n/* harmony export */   toByteString: function() { return /* binding */ toByteString; },\n/* harmony export */   toHex: function() { return /* binding */ toHex; }\n/* harmony export */ });\n/**\n * Code modified from https://github.com/google/tink/blob/6f74b99a2bfe6677e3670799116a57268fd067fa/javascript/subtle/bytes.ts\n *\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * Converts the hex string to a byte array.\n *\n * @param hex the input\n * @return the byte array output\n * @throws {!Error}\n * @static\n */\nfunction fromHex(hex) {\n    if (hex.length % 2 != 0) {\n        throw new Error(\"Hex string length must be multiple of 2\");\n    }\n    const arr = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < hex.length; i += 2) {\n        arr[i / 2] = parseInt(hex.substring(i, i + 2), 16);\n    }\n    return arr;\n}\n/**\n * Converts a byte array to hex.\n *\n * @param bytes the byte array input\n * @return hex the output\n * @static\n */\nfunction toHex(bytes) {\n    let result = \"\";\n    for (let i = 0; i < bytes.length; i++) {\n        const hexByte = bytes[i].toString(16);\n        result += hexByte.length > 1 ? hexByte : \"0\" + hexByte;\n    }\n    return result;\n}\n/**\n * Base64 encode a byte array.\n *\n * @param bytes the byte array input\n * @param opt_webSafe True indicates we should use the alternative\n *     alphabet, which does not require escaping for use in URLs.\n * @return base64 output\n * @static\n */\nfunction toBase64(bytes, opt_webSafe) {\n    const encoded = btoa(\n    /* padding */\n    toByteString(bytes)).replace(/=/g, \"\");\n    if (opt_webSafe) {\n        return encoded.replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n    }\n    return encoded;\n}\n/**\n * Turns a byte array into the string given by the concatenation of the\n * characters to which the numbers correspond. Each byte is corresponding to a\n * character. Does not support multi-byte characters.\n *\n * @param bytes Array of numbers representing\n *     characters.\n * @return Stringification of the array.\n */\nfunction toByteString(bytes) {\n    let str = \"\";\n    for (let i = 0; i < bytes.length; i += 1) {\n        str += String.fromCharCode(bytes[i]);\n    }\n    return str;\n}\n\n\n//# sourceMappingURL=bytes.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdHVybmtleS9hcGkta2V5LXN0YW1wZXIvZGlzdC90aW5rL2J5dGVzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVrRDtBQUNsRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvYXBpLWtleS1zdGFtcGVyL2Rpc3QvdGluay9ieXRlcy5tanM/YWI1MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvZGUgbW9kaWZpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL3RpbmsvYmxvYi82Zjc0Yjk5YTJiZmU2Njc3ZTM2NzA3OTkxMTZhNTcyNjhmZDA2N2ZhL2phdmFzY3JpcHQvc3VidGxlL2J5dGVzLnRzXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8qKlxuICogQ29udmVydHMgdGhlIGhleCBzdHJpbmcgdG8gYSBieXRlIGFycmF5LlxuICpcbiAqIEBwYXJhbSBoZXggdGhlIGlucHV0XG4gKiBAcmV0dXJuIHRoZSBieXRlIGFycmF5IG91dHB1dFxuICogQHRocm93cyB7IUVycm9yfVxuICogQHN0YXRpY1xuICovXG5mdW5jdGlvbiBmcm9tSGV4KGhleCkge1xuICAgIGlmIChoZXgubGVuZ3RoICUgMiAhPSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkhleCBzdHJpbmcgbGVuZ3RoIG11c3QgYmUgbXVsdGlwbGUgb2YgMlwiKTtcbiAgICB9XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoaGV4Lmxlbmd0aCAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGV4Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGFycltpIC8gMl0gPSBwYXJzZUludChoZXguc3Vic3RyaW5nKGksIGkgKyAyKSwgMTYpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGJ5dGUgYXJyYXkgdG8gaGV4LlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZSBhcnJheSBpbnB1dFxuICogQHJldHVybiBoZXggdGhlIG91dHB1dFxuICogQHN0YXRpY1xuICovXG5mdW5jdGlvbiB0b0hleChieXRlcykge1xuICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaGV4Qnl0ZSA9IGJ5dGVzW2ldLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgcmVzdWx0ICs9IGhleEJ5dGUubGVuZ3RoID4gMSA/IGhleEJ5dGUgOiBcIjBcIiArIGhleEJ5dGU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEJhc2U2NCBlbmNvZGUgYSBieXRlIGFycmF5LlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZSBhcnJheSBpbnB1dFxuICogQHBhcmFtIG9wdF93ZWJTYWZlIFRydWUgaW5kaWNhdGVzIHdlIHNob3VsZCB1c2UgdGhlIGFsdGVybmF0aXZlXG4gKiAgICAgYWxwaGFiZXQsIHdoaWNoIGRvZXMgbm90IHJlcXVpcmUgZXNjYXBpbmcgZm9yIHVzZSBpbiBVUkxzLlxuICogQHJldHVybiBiYXNlNjQgb3V0cHV0XG4gKiBAc3RhdGljXG4gKi9cbmZ1bmN0aW9uIHRvQmFzZTY0KGJ5dGVzLCBvcHRfd2ViU2FmZSkge1xuICAgIGNvbnN0IGVuY29kZWQgPSBidG9hKFxuICAgIC8qIHBhZGRpbmcgKi9cbiAgICB0b0J5dGVTdHJpbmcoYnl0ZXMpKS5yZXBsYWNlKC89L2csIFwiXCIpO1xuICAgIGlmIChvcHRfd2ViU2FmZSkge1xuICAgICAgICByZXR1cm4gZW5jb2RlZC5yZXBsYWNlKC9cXCsvZywgXCItXCIpLnJlcGxhY2UoL1xcLy9nLCBcIl9cIik7XG4gICAgfVxuICAgIHJldHVybiBlbmNvZGVkO1xufVxuLyoqXG4gKiBUdXJucyBhIGJ5dGUgYXJyYXkgaW50byB0aGUgc3RyaW5nIGdpdmVuIGJ5IHRoZSBjb25jYXRlbmF0aW9uIG9mIHRoZVxuICogY2hhcmFjdGVycyB0byB3aGljaCB0aGUgbnVtYmVycyBjb3JyZXNwb25kLiBFYWNoIGJ5dGUgaXMgY29ycmVzcG9uZGluZyB0byBhXG4gKiBjaGFyYWN0ZXIuIERvZXMgbm90IHN1cHBvcnQgbXVsdGktYnl0ZSBjaGFyYWN0ZXJzLlxuICpcbiAqIEBwYXJhbSBieXRlcyBBcnJheSBvZiBudW1iZXJzIHJlcHJlc2VudGluZ1xuICogICAgIGNoYXJhY3RlcnMuXG4gKiBAcmV0dXJuIFN0cmluZ2lmaWNhdGlvbiBvZiB0aGUgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvQnl0ZVN0cmluZyhieXRlcykge1xuICAgIGxldCBzdHIgPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuXG5leHBvcnQgeyBmcm9tSGV4LCB0b0Jhc2U2NCwgdG9CeXRlU3RyaW5nLCB0b0hleCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ynl0ZXMubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@turnkey/api-key-stamper/dist/tink/bytes.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@turnkey/api-key-stamper/dist/tink/elliptic_curves.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@turnkey/api-key-stamper/dist/tink/elliptic_curves.mjs ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pointDecode: function() { return /* binding */ pointDecode; }\n/* harmony export */ });\n/* harmony import */ var _bytes_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bytes.mjs */ \"(app-pages-browser)/./node_modules/@turnkey/api-key-stamper/dist/tink/bytes.mjs\");\n\n\n/**\n * Code modified from https://github.com/google/tink/blob/6f74b99a2bfe6677e3670799116a57268fd067fa/javascript/subtle/elliptic_curves.ts\n *\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * P-256 only\n */\nfunction getModulus() {\n    // https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf (Appendix D).\n    return BigInt(\"115792089210356248762697446949407573530086143415290314195533631308\" +\n        \"867097853951\");\n}\n/**\n * P-256 only\n */\nfunction getB() {\n    // https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf (Appendix D).\n    return BigInt(\"0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b\");\n}\n/** Converts byte array to bigint. */\nfunction byteArrayToInteger(bytes) {\n    return BigInt(\"0x\" + (0,_bytes_mjs__WEBPACK_IMPORTED_MODULE_0__.toHex)(bytes));\n}\n/** Converts bigint to byte array. */\nfunction integerToByteArray(i) {\n    let input = i.toString(16);\n    // If necessary, prepend leading zero to ensure that input length is even.\n    input = input.length % 2 === 0 ? input : \"0\" + input;\n    return (0,_bytes_mjs__WEBPACK_IMPORTED_MODULE_0__.fromHex)(input);\n}\n/** Returns true iff the ith bit (in lsb order) of n is set. */\nfunction testBit(n, i) {\n    const m = BigInt(1) << BigInt(i);\n    return (n & m) !== BigInt(0);\n}\n/**\n * Computes a modular exponent.  Since JavaScript BigInt operations are not\n * constant-time, information about the inputs could leak.  Therefore, THIS\n * METHOD SHOULD ONLY BE USED FOR POINT DECOMPRESSION.\n *\n * @param b base\n * @param exp exponent\n * @param p modulus\n * @return b^exp modulo p\n */\nfunction modPow(b, exp, p) {\n    if (exp === BigInt(0)) {\n        return BigInt(1);\n    }\n    let result = b;\n    const exponentBitString = exp.toString(2);\n    for (let i = 1; i < exponentBitString.length; ++i) {\n        result = (result * result) % p;\n        if (exponentBitString[i] === \"1\") {\n            result = (result * b) % p;\n        }\n    }\n    return result;\n}\n/**\n * Computes a square root modulo an odd prime.  Since timing and exceptions can\n * leak information about the inputs, THIS METHOD SHOULD ONLY BE USED FOR\n * POINT DECOMPRESSION.\n *\n * @param x square\n * @param p prime modulus\n * @return square root of x modulo p\n */\nfunction modSqrt(x, p) {\n    if (p <= BigInt(0)) {\n        throw new Error(\"p must be positive\");\n    }\n    const base = x % p;\n    // The currently supported NIST curves P-256, P-384, and P-521 all satisfy\n    // p % 4 == 3.  However, although currently a no-op, the following check\n    // should be left in place in case other curves are supported in the future.\n    if (testBit(p, 0) && /* istanbul ignore next */ testBit(p, 1)) {\n        // Case p % 4 == 3 (applies to NIST curves P-256, P-384, and P-521)\n        // q = (p + 1) / 4\n        const q = (p + BigInt(1)) >> BigInt(2);\n        const squareRoot = modPow(base, q, p);\n        if ((squareRoot * squareRoot) % p !== base) {\n            throw new Error(\"could not find a modular square root\");\n        }\n        return squareRoot;\n    }\n    // Skipping other elliptic curve types that require Cipolla's algorithm.\n    throw new Error(\"unsupported modulus value\");\n}\n/**\n * Computes the y-coordinate of a point on an elliptic curve given its\n * x-coordinate.  Since timing and exceptions can leak information about the\n * inputs, THIS METHOD SHOULD ONLY BE USED FOR POINT DECOMPRESSION.\n *\n * P-256 only\n *\n * @param x x-coordinate\n * @param lsb least significant bit of the y-coordinate\n * @return y-coordinate\n */\nfunction getY(x, lsb) {\n    const p = getModulus();\n    const a = p - BigInt(3);\n    const b = getB();\n    const rhs = ((x * x + a) * x + b) % p;\n    let y = modSqrt(rhs, p);\n    if (lsb !== testBit(y, 0)) {\n        y = (p - y) % p;\n    }\n    return y;\n}\n/**\n * Decodes a public key in _compressed_ format.\n *\n * P-256 only\n */\nfunction pointDecode(point) {\n    const fieldSize = fieldSizeInBytes();\n    if (point.length !== 1 + fieldSize) {\n        throw new Error(\"compressed point has wrong length\");\n    }\n    if (point[0] !== 2 && point[0] !== 3) {\n        throw new Error(\"invalid format\");\n    }\n    const lsb = point[0] === 3; // point[0] must be 2 (false) or 3 (true).\n    const x = byteArrayToInteger(point.subarray(1, point.length));\n    const p = getModulus();\n    if (x < BigInt(0) || x >= p) {\n        throw new Error(\"x is out of range\");\n    }\n    const y = getY(x, lsb);\n    const result = {\n        kty: \"EC\",\n        crv: \"P-256\",\n        x: (0,_bytes_mjs__WEBPACK_IMPORTED_MODULE_0__.toBase64)(integerToByteArray(x), /* websafe */ true),\n        y: (0,_bytes_mjs__WEBPACK_IMPORTED_MODULE_0__.toBase64)(integerToByteArray(y), /* websafe */ true),\n        ext: true,\n    };\n    return result;\n}\n/**\n * P-256 only\n */\nfunction fieldSizeInBytes() {\n    return 32;\n}\n\n\n//# sourceMappingURL=elliptic_curves.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdHVybmtleS9hcGkta2V5LXN0YW1wZXIvZGlzdC90aW5rL2VsbGlwdGljX2N1cnZlcy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBdUQ7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpREFBSztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1EQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhCQUE4QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvREFBUTtBQUNuQixXQUFXLG9EQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV1QjtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvYXBpLWtleS1zdGFtcGVyL2Rpc3QvdGluay9lbGxpcHRpY19jdXJ2ZXMubWpzPzg2ODUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdG9CYXNlNjQsIHRvSGV4LCBmcm9tSGV4IH0gZnJvbSAnLi9ieXRlcy5tanMnO1xuXG4vKipcbiAqIENvZGUgbW9kaWZpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL3RpbmsvYmxvYi82Zjc0Yjk5YTJiZmU2Njc3ZTM2NzA3OTkxMTZhNTcyNjhmZDA2N2ZhL2phdmFzY3JpcHQvc3VidGxlL2VsbGlwdGljX2N1cnZlcy50c1xuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vKipcbiAqIFAtMjU2IG9ubHlcbiAqL1xuZnVuY3Rpb24gZ2V0TW9kdWx1cygpIHtcbiAgICAvLyBodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvRklQUy9OSVNULkZJUFMuMTg2LTQucGRmIChBcHBlbmRpeCBEKS5cbiAgICByZXR1cm4gQmlnSW50KFwiMTE1NzkyMDg5MjEwMzU2MjQ4NzYyNjk3NDQ2OTQ5NDA3NTczNTMwMDg2MTQzNDE1MjkwMzE0MTk1NTMzNjMxMzA4XCIgK1xuICAgICAgICBcIjg2NzA5Nzg1Mzk1MVwiKTtcbn1cbi8qKlxuICogUC0yNTYgb25seVxuICovXG5mdW5jdGlvbiBnZXRCKCkge1xuICAgIC8vIGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9GSVBTL05JU1QuRklQUy4xODYtNC5wZGYgKEFwcGVuZGl4IEQpLlxuICAgIHJldHVybiBCaWdJbnQoXCIweDVhYzYzNWQ4YWEzYTkzZTdiM2ViYmQ1NTc2OTg4NmJjNjUxZDA2YjBjYzUzYjBmNjNiY2UzYzNlMjdkMjYwNGJcIik7XG59XG4vKiogQ29udmVydHMgYnl0ZSBhcnJheSB0byBiaWdpbnQuICovXG5mdW5jdGlvbiBieXRlQXJyYXlUb0ludGVnZXIoYnl0ZXMpIHtcbiAgICByZXR1cm4gQmlnSW50KFwiMHhcIiArIHRvSGV4KGJ5dGVzKSk7XG59XG4vKiogQ29udmVydHMgYmlnaW50IHRvIGJ5dGUgYXJyYXkuICovXG5mdW5jdGlvbiBpbnRlZ2VyVG9CeXRlQXJyYXkoaSkge1xuICAgIGxldCBpbnB1dCA9IGkudG9TdHJpbmcoMTYpO1xuICAgIC8vIElmIG5lY2Vzc2FyeSwgcHJlcGVuZCBsZWFkaW5nIHplcm8gdG8gZW5zdXJlIHRoYXQgaW5wdXQgbGVuZ3RoIGlzIGV2ZW4uXG4gICAgaW5wdXQgPSBpbnB1dC5sZW5ndGggJSAyID09PSAwID8gaW5wdXQgOiBcIjBcIiArIGlucHV0O1xuICAgIHJldHVybiBmcm9tSGV4KGlucHV0KTtcbn1cbi8qKiBSZXR1cm5zIHRydWUgaWZmIHRoZSBpdGggYml0IChpbiBsc2Igb3JkZXIpIG9mIG4gaXMgc2V0LiAqL1xuZnVuY3Rpb24gdGVzdEJpdChuLCBpKSB7XG4gICAgY29uc3QgbSA9IEJpZ0ludCgxKSA8PCBCaWdJbnQoaSk7XG4gICAgcmV0dXJuIChuICYgbSkgIT09IEJpZ0ludCgwKTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgYSBtb2R1bGFyIGV4cG9uZW50LiAgU2luY2UgSmF2YVNjcmlwdCBCaWdJbnQgb3BlcmF0aW9ucyBhcmUgbm90XG4gKiBjb25zdGFudC10aW1lLCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgaW5wdXRzIGNvdWxkIGxlYWsuICBUaGVyZWZvcmUsIFRISVNcbiAqIE1FVEhPRCBTSE9VTEQgT05MWSBCRSBVU0VEIEZPUiBQT0lOVCBERUNPTVBSRVNTSU9OLlxuICpcbiAqIEBwYXJhbSBiIGJhc2VcbiAqIEBwYXJhbSBleHAgZXhwb25lbnRcbiAqIEBwYXJhbSBwIG1vZHVsdXNcbiAqIEByZXR1cm4gYl5leHAgbW9kdWxvIHBcbiAqL1xuZnVuY3Rpb24gbW9kUG93KGIsIGV4cCwgcCkge1xuICAgIGlmIChleHAgPT09IEJpZ0ludCgwKSkge1xuICAgICAgICByZXR1cm4gQmlnSW50KDEpO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gYjtcbiAgICBjb25zdCBleHBvbmVudEJpdFN0cmluZyA9IGV4cC50b1N0cmluZygyKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGV4cG9uZW50Qml0U3RyaW5nLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHJlc3VsdCA9IChyZXN1bHQgKiByZXN1bHQpICUgcDtcbiAgICAgICAgaWYgKGV4cG9uZW50Qml0U3RyaW5nW2ldID09PSBcIjFcIikge1xuICAgICAgICAgICAgcmVzdWx0ID0gKHJlc3VsdCAqIGIpICUgcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBDb21wdXRlcyBhIHNxdWFyZSByb290IG1vZHVsbyBhbiBvZGQgcHJpbWUuICBTaW5jZSB0aW1pbmcgYW5kIGV4Y2VwdGlvbnMgY2FuXG4gKiBsZWFrIGluZm9ybWF0aW9uIGFib3V0IHRoZSBpbnB1dHMsIFRISVMgTUVUSE9EIFNIT1VMRCBPTkxZIEJFIFVTRUQgRk9SXG4gKiBQT0lOVCBERUNPTVBSRVNTSU9OLlxuICpcbiAqIEBwYXJhbSB4IHNxdWFyZVxuICogQHBhcmFtIHAgcHJpbWUgbW9kdWx1c1xuICogQHJldHVybiBzcXVhcmUgcm9vdCBvZiB4IG1vZHVsbyBwXG4gKi9cbmZ1bmN0aW9uIG1vZFNxcnQoeCwgcCkge1xuICAgIGlmIChwIDw9IEJpZ0ludCgwKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwIG11c3QgYmUgcG9zaXRpdmVcIik7XG4gICAgfVxuICAgIGNvbnN0IGJhc2UgPSB4ICUgcDtcbiAgICAvLyBUaGUgY3VycmVudGx5IHN1cHBvcnRlZCBOSVNUIGN1cnZlcyBQLTI1NiwgUC0zODQsIGFuZCBQLTUyMSBhbGwgc2F0aXNmeVxuICAgIC8vIHAgJSA0ID09IDMuICBIb3dldmVyLCBhbHRob3VnaCBjdXJyZW50bHkgYSBuby1vcCwgdGhlIGZvbGxvd2luZyBjaGVja1xuICAgIC8vIHNob3VsZCBiZSBsZWZ0IGluIHBsYWNlIGluIGNhc2Ugb3RoZXIgY3VydmVzIGFyZSBzdXBwb3J0ZWQgaW4gdGhlIGZ1dHVyZS5cbiAgICBpZiAodGVzdEJpdChwLCAwKSAmJiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB0ZXN0Qml0KHAsIDEpKSB7XG4gICAgICAgIC8vIENhc2UgcCAlIDQgPT0gMyAoYXBwbGllcyB0byBOSVNUIGN1cnZlcyBQLTI1NiwgUC0zODQsIGFuZCBQLTUyMSlcbiAgICAgICAgLy8gcSA9IChwICsgMSkgLyA0XG4gICAgICAgIGNvbnN0IHEgPSAocCArIEJpZ0ludCgxKSkgPj4gQmlnSW50KDIpO1xuICAgICAgICBjb25zdCBzcXVhcmVSb290ID0gbW9kUG93KGJhc2UsIHEsIHApO1xuICAgICAgICBpZiAoKHNxdWFyZVJvb3QgKiBzcXVhcmVSb290KSAlIHAgIT09IGJhc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvdWxkIG5vdCBmaW5kIGEgbW9kdWxhciBzcXVhcmUgcm9vdFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3F1YXJlUm9vdDtcbiAgICB9XG4gICAgLy8gU2tpcHBpbmcgb3RoZXIgZWxsaXB0aWMgY3VydmUgdHlwZXMgdGhhdCByZXF1aXJlIENpcG9sbGEncyBhbGdvcml0aG0uXG4gICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgbW9kdWx1cyB2YWx1ZVwiKTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIHktY29vcmRpbmF0ZSBvZiBhIHBvaW50IG9uIGFuIGVsbGlwdGljIGN1cnZlIGdpdmVuIGl0c1xuICogeC1jb29yZGluYXRlLiAgU2luY2UgdGltaW5nIGFuZCBleGNlcHRpb25zIGNhbiBsZWFrIGluZm9ybWF0aW9uIGFib3V0IHRoZVxuICogaW5wdXRzLCBUSElTIE1FVEhPRCBTSE9VTEQgT05MWSBCRSBVU0VEIEZPUiBQT0lOVCBERUNPTVBSRVNTSU9OLlxuICpcbiAqIFAtMjU2IG9ubHlcbiAqXG4gKiBAcGFyYW0geCB4LWNvb3JkaW5hdGVcbiAqIEBwYXJhbSBsc2IgbGVhc3Qgc2lnbmlmaWNhbnQgYml0IG9mIHRoZSB5LWNvb3JkaW5hdGVcbiAqIEByZXR1cm4geS1jb29yZGluYXRlXG4gKi9cbmZ1bmN0aW9uIGdldFkoeCwgbHNiKSB7XG4gICAgY29uc3QgcCA9IGdldE1vZHVsdXMoKTtcbiAgICBjb25zdCBhID0gcCAtIEJpZ0ludCgzKTtcbiAgICBjb25zdCBiID0gZ2V0QigpO1xuICAgIGNvbnN0IHJocyA9ICgoeCAqIHggKyBhKSAqIHggKyBiKSAlIHA7XG4gICAgbGV0IHkgPSBtb2RTcXJ0KHJocywgcCk7XG4gICAgaWYgKGxzYiAhPT0gdGVzdEJpdCh5LCAwKSkge1xuICAgICAgICB5ID0gKHAgLSB5KSAlIHA7XG4gICAgfVxuICAgIHJldHVybiB5O1xufVxuLyoqXG4gKiBEZWNvZGVzIGEgcHVibGljIGtleSBpbiBfY29tcHJlc3NlZF8gZm9ybWF0LlxuICpcbiAqIFAtMjU2IG9ubHlcbiAqL1xuZnVuY3Rpb24gcG9pbnREZWNvZGUocG9pbnQpIHtcbiAgICBjb25zdCBmaWVsZFNpemUgPSBmaWVsZFNpemVJbkJ5dGVzKCk7XG4gICAgaWYgKHBvaW50Lmxlbmd0aCAhPT0gMSArIGZpZWxkU2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb21wcmVzc2VkIHBvaW50IGhhcyB3cm9uZyBsZW5ndGhcIik7XG4gICAgfVxuICAgIGlmIChwb2ludFswXSAhPT0gMiAmJiBwb2ludFswXSAhPT0gMykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZvcm1hdFwiKTtcbiAgICB9XG4gICAgY29uc3QgbHNiID0gcG9pbnRbMF0gPT09IDM7IC8vIHBvaW50WzBdIG11c3QgYmUgMiAoZmFsc2UpIG9yIDMgKHRydWUpLlxuICAgIGNvbnN0IHggPSBieXRlQXJyYXlUb0ludGVnZXIocG9pbnQuc3ViYXJyYXkoMSwgcG9pbnQubGVuZ3RoKSk7XG4gICAgY29uc3QgcCA9IGdldE1vZHVsdXMoKTtcbiAgICBpZiAoeCA8IEJpZ0ludCgwKSB8fCB4ID49IHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwieCBpcyBvdXQgb2YgcmFuZ2VcIik7XG4gICAgfVxuICAgIGNvbnN0IHkgPSBnZXRZKHgsIGxzYik7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBrdHk6IFwiRUNcIixcbiAgICAgICAgY3J2OiBcIlAtMjU2XCIsXG4gICAgICAgIHg6IHRvQmFzZTY0KGludGVnZXJUb0J5dGVBcnJheSh4KSwgLyogd2Vic2FmZSAqLyB0cnVlKSxcbiAgICAgICAgeTogdG9CYXNlNjQoaW50ZWdlclRvQnl0ZUFycmF5KHkpLCAvKiB3ZWJzYWZlICovIHRydWUpLFxuICAgICAgICBleHQ6IHRydWUsXG4gICAgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBQLTI1NiBvbmx5XG4gKi9cbmZ1bmN0aW9uIGZpZWxkU2l6ZUluQnl0ZXMoKSB7XG4gICAgcmV0dXJuIDMyO1xufVxuXG5leHBvcnQgeyBwb2ludERlY29kZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWxsaXB0aWNfY3VydmVzLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@turnkey/api-key-stamper/dist/tink/elliptic_curves.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@turnkey/api-key-stamper/dist/utils.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@turnkey/api-key-stamper/dist/utils.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertTurnkeyApiKeyToJwk: function() { return /* binding */ convertTurnkeyApiKeyToJwk; }\n/* harmony export */ });\n/* harmony import */ var _tink_elliptic_curves_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tink/elliptic_curves.mjs */ \"(app-pages-browser)/./node_modules/@turnkey/api-key-stamper/dist/tink/elliptic_curves.mjs\");\n/* harmony import */ var _turnkey_encoding__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @turnkey/encoding */ \"(app-pages-browser)/./node_modules/@turnkey/encoding/dist/index.mjs\");\n\n\n\nfunction convertTurnkeyApiKeyToJwk(input) {\n    const { uncompressedPrivateKeyHex, compressedPublicKeyHex } = input;\n    const jwk = (0,_tink_elliptic_curves_mjs__WEBPACK_IMPORTED_MODULE_0__.pointDecode)(hexStringToUint8Array(compressedPublicKeyHex));\n    jwk.d = hexStringToBase64urlString(uncompressedPrivateKeyHex);\n    return jwk;\n}\nfunction hexStringToUint8Array(input) {\n    if (input.length === 0 ||\n        input.length % 2 !== 0 ||\n        /[^a-fA-F0-9]/u.test(input)) {\n        throw new Error(`Invalid hex string: ${JSON.stringify(input)}`);\n    }\n    return Uint8Array.from(input\n        .match(/.{2}/g // Split string by every two characters\n    )\n        .map((byte) => parseInt(byte, 16)));\n}\nfunction hexStringToBase64urlString(input) {\n    const buffer = hexStringToUint8Array(input);\n    return (0,_turnkey_encoding__WEBPACK_IMPORTED_MODULE_1__.stringToBase64urlString)(buffer.reduce((result, x) => result + String.fromCharCode(x), \"\"));\n}\n\n\n//# sourceMappingURL=utils.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdHVybmtleS9hcGkta2V5LXN0YW1wZXIvZGlzdC91dGlscy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXlEO0FBQ0c7O0FBRTVEO0FBQ0EsWUFBWSxvREFBb0Q7QUFDaEUsZ0JBQWdCLHNFQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHNCQUFzQjtBQUNyRTtBQUNBO0FBQ0Esa0JBQWtCLEVBQUU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMEVBQXVCO0FBQ2xDOztBQUVxQztBQUNyQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvYXBpLWtleS1zdGFtcGVyL2Rpc3QvdXRpbHMubWpzP2FkZjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcG9pbnREZWNvZGUgfSBmcm9tICcuL3RpbmsvZWxsaXB0aWNfY3VydmVzLm1qcyc7XG5pbXBvcnQgeyBzdHJpbmdUb0Jhc2U2NHVybFN0cmluZyB9IGZyb20gJ0B0dXJua2V5L2VuY29kaW5nJztcblxuZnVuY3Rpb24gY29udmVydFR1cm5rZXlBcGlLZXlUb0p3ayhpbnB1dCkge1xuICAgIGNvbnN0IHsgdW5jb21wcmVzc2VkUHJpdmF0ZUtleUhleCwgY29tcHJlc3NlZFB1YmxpY0tleUhleCB9ID0gaW5wdXQ7XG4gICAgY29uc3QgandrID0gcG9pbnREZWNvZGUoaGV4U3RyaW5nVG9VaW50OEFycmF5KGNvbXByZXNzZWRQdWJsaWNLZXlIZXgpKTtcbiAgICBqd2suZCA9IGhleFN0cmluZ1RvQmFzZTY0dXJsU3RyaW5nKHVuY29tcHJlc3NlZFByaXZhdGVLZXlIZXgpO1xuICAgIHJldHVybiBqd2s7XG59XG5mdW5jdGlvbiBoZXhTdHJpbmdUb1VpbnQ4QXJyYXkoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQubGVuZ3RoID09PSAwIHx8XG4gICAgICAgIGlucHV0Lmxlbmd0aCAlIDIgIT09IDAgfHxcbiAgICAgICAgL1teYS1mQS1GMC05XS91LnRlc3QoaW5wdXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBoZXggc3RyaW5nOiAke0pTT04uc3RyaW5naWZ5KGlucHV0KX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShpbnB1dFxuICAgICAgICAubWF0Y2goLy57Mn0vZyAvLyBTcGxpdCBzdHJpbmcgYnkgZXZlcnkgdHdvIGNoYXJhY3RlcnNcbiAgICApXG4gICAgICAgIC5tYXAoKGJ5dGUpID0+IHBhcnNlSW50KGJ5dGUsIDE2KSkpO1xufVxuZnVuY3Rpb24gaGV4U3RyaW5nVG9CYXNlNjR1cmxTdHJpbmcoaW5wdXQpIHtcbiAgICBjb25zdCBidWZmZXIgPSBoZXhTdHJpbmdUb1VpbnQ4QXJyYXkoaW5wdXQpO1xuICAgIHJldHVybiBzdHJpbmdUb0Jhc2U2NHVybFN0cmluZyhidWZmZXIucmVkdWNlKChyZXN1bHQsIHgpID0+IHJlc3VsdCArIFN0cmluZy5mcm9tQ2hhckNvZGUoeCksIFwiXCIpKTtcbn1cblxuZXhwb3J0IHsgY29udmVydFR1cm5rZXlBcGlLZXlUb0p3ayB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@turnkey/api-key-stamper/dist/utils.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@turnkey/api-key-stamper/dist/webcrypto.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@turnkey/api-key-stamper/dist/webcrypto.mjs ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   signWithApiKey: function() { return /* binding */ signWithApiKey; }\n/* harmony export */ });\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.mjs */ \"(app-pages-browser)/./node_modules/@turnkey/api-key-stamper/dist/utils.mjs\");\n/* harmony import */ var _turnkey_encoding__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @turnkey/encoding */ \"(app-pages-browser)/./node_modules/@turnkey/encoding/dist/index.mjs\");\n\n\n\n/// <reference lib=\"dom\" />\nconst signWithApiKey = async (input) => {\n    const { content, publicKey, privateKey } = input;\n    const key = await importTurnkeyApiKey({\n        uncompressedPrivateKeyHex: privateKey,\n        compressedPublicKeyHex: publicKey,\n    });\n    return await signMessage({ key, content });\n};\nasync function importTurnkeyApiKey(input) {\n    const { uncompressedPrivateKeyHex, compressedPublicKeyHex } = input;\n    const jwk = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.convertTurnkeyApiKeyToJwk)({\n        uncompressedPrivateKeyHex,\n        compressedPublicKeyHex,\n    });\n    return await crypto.subtle.importKey(\"jwk\", jwk, {\n        name: \"ECDSA\",\n        namedCurve: \"P-256\",\n    }, false, // not extractable\n    [\"sign\"] // allow signing\n    );\n}\nasync function signMessage(input) {\n    const { key, content } = input;\n    const signatureIeee1363 = await crypto.subtle.sign({\n        name: \"ECDSA\",\n        hash: \"SHA-256\",\n    }, key, new TextEncoder().encode(content));\n    const signatureDer = convertEcdsaIeee1363ToDer(new Uint8Array(signatureIeee1363));\n    return (0,_turnkey_encoding__WEBPACK_IMPORTED_MODULE_1__.uint8ArrayToHexString)(signatureDer);\n}\n/**\n * `SubtleCrypto.sign(...)` outputs signature in IEEE P1363 format:\n * - https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/sign#ecdsa\n *\n * Turnkey expects the signature encoding to be DER-encoded ASN.1:\n * - https://github.com/tkhq/tkcli/blob/7f0159af5a73387ff050647180d1db4d3a3aa033/src/internal/apikey/apikey.go#L149\n *\n * Code modified from https://github.com/google/tink/blob/6f74b99a2bfe6677e3670799116a57268fd067fa/javascript/subtle/elliptic_curves.ts#L114\n *\n * Transform an ECDSA signature in IEEE 1363 encoding to DER encoding.\n *\n * @param ieee the ECDSA signature in IEEE encoding\n * @return ECDSA signature in DER encoding\n */\nfunction convertEcdsaIeee1363ToDer(ieee) {\n    if (ieee.length % 2 != 0 || ieee.length == 0 || ieee.length > 132) {\n        throw new Error(\"Invalid IEEE P1363 signature encoding. Length: \" + ieee.length);\n    }\n    const r = toUnsignedBigNum(ieee.subarray(0, ieee.length / 2));\n    const s = toUnsignedBigNum(ieee.subarray(ieee.length / 2, ieee.length));\n    let offset = 0;\n    const length = 1 + 1 + r.length + 1 + 1 + s.length;\n    let der;\n    if (length >= 128) {\n        der = new Uint8Array(length + 3);\n        der[offset++] = 48;\n        der[offset++] = 128 + 1;\n        der[offset++] = length;\n    }\n    else {\n        der = new Uint8Array(length + 2);\n        der[offset++] = 48;\n        der[offset++] = length;\n    }\n    der[offset++] = 2;\n    der[offset++] = r.length;\n    der.set(r, offset);\n    offset += r.length;\n    der[offset++] = 2;\n    der[offset++] = s.length;\n    der.set(s, offset);\n    return der;\n}\n/**\n * Code modified from https://github.com/google/tink/blob/6f74b99a2bfe6677e3670799116a57268fd067fa/javascript/subtle/elliptic_curves.ts#L311\n *\n * Transform a big integer in big endian to minimal unsigned form which has\n * no extra zero at the beginning except when the highest bit is set.\n */\nfunction toUnsignedBigNum(bytes) {\n    // Remove zero prefixes.\n    let start = 0;\n    while (start < bytes.length && bytes[start] == 0) {\n        start++;\n    }\n    if (start == bytes.length) {\n        start = bytes.length - 1;\n    }\n    let extraZero = 0;\n    // If the 1st bit is not zero, add 1 zero byte.\n    if ((bytes[start] & 128) == 128) {\n        // Add extra zero.\n        extraZero = 1;\n    }\n    const res = new Uint8Array(bytes.length - start + extraZero);\n    res.set(bytes.subarray(start), extraZero);\n    return res;\n}\n\n\n//# sourceMappingURL=webcrypto.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdHVybmtleS9hcGkta2V5LXN0YW1wZXIvZGlzdC93ZWJjcnlwdG8ubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF3RDtBQUNFOztBQUUxRDtBQUNBO0FBQ0EsWUFBWSxpQ0FBaUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLCtCQUErQixjQUFjO0FBQzdDO0FBQ0E7QUFDQSxZQUFZLG9EQUFvRDtBQUNoRSxnQkFBZ0IscUVBQXlCO0FBQ3pDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFdBQVcsd0VBQXFCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMEI7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B0dXJua2V5L2FwaS1rZXktc3RhbXBlci9kaXN0L3dlYmNyeXB0by5tanM/NzA1MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb252ZXJ0VHVybmtleUFwaUtleVRvSndrIH0gZnJvbSAnLi91dGlscy5tanMnO1xuaW1wb3J0IHsgdWludDhBcnJheVRvSGV4U3RyaW5nIH0gZnJvbSAnQHR1cm5rZXkvZW5jb2RpbmcnO1xuXG4vLy8gPHJlZmVyZW5jZSBsaWI9XCJkb21cIiAvPlxuY29uc3Qgc2lnbldpdGhBcGlLZXkgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICBjb25zdCB7IGNvbnRlbnQsIHB1YmxpY0tleSwgcHJpdmF0ZUtleSB9ID0gaW5wdXQ7XG4gICAgY29uc3Qga2V5ID0gYXdhaXQgaW1wb3J0VHVybmtleUFwaUtleSh7XG4gICAgICAgIHVuY29tcHJlc3NlZFByaXZhdGVLZXlIZXg6IHByaXZhdGVLZXksXG4gICAgICAgIGNvbXByZXNzZWRQdWJsaWNLZXlIZXg6IHB1YmxpY0tleSxcbiAgICB9KTtcbiAgICByZXR1cm4gYXdhaXQgc2lnbk1lc3NhZ2UoeyBrZXksIGNvbnRlbnQgfSk7XG59O1xuYXN5bmMgZnVuY3Rpb24gaW1wb3J0VHVybmtleUFwaUtleShpbnB1dCkge1xuICAgIGNvbnN0IHsgdW5jb21wcmVzc2VkUHJpdmF0ZUtleUhleCwgY29tcHJlc3NlZFB1YmxpY0tleUhleCB9ID0gaW5wdXQ7XG4gICAgY29uc3QgandrID0gY29udmVydFR1cm5rZXlBcGlLZXlUb0p3ayh7XG4gICAgICAgIHVuY29tcHJlc3NlZFByaXZhdGVLZXlIZXgsXG4gICAgICAgIGNvbXByZXNzZWRQdWJsaWNLZXlIZXgsXG4gICAgfSk7XG4gICAgcmV0dXJuIGF3YWl0IGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFwiandrXCIsIGp3aywge1xuICAgICAgICBuYW1lOiBcIkVDRFNBXCIsXG4gICAgICAgIG5hbWVkQ3VydmU6IFwiUC0yNTZcIixcbiAgICB9LCBmYWxzZSwgLy8gbm90IGV4dHJhY3RhYmxlXG4gICAgW1wic2lnblwiXSAvLyBhbGxvdyBzaWduaW5nXG4gICAgKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNpZ25NZXNzYWdlKGlucHV0KSB7XG4gICAgY29uc3QgeyBrZXksIGNvbnRlbnQgfSA9IGlucHV0O1xuICAgIGNvbnN0IHNpZ25hdHVyZUllZWUxMzYzID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5zaWduKHtcbiAgICAgICAgbmFtZTogXCJFQ0RTQVwiLFxuICAgICAgICBoYXNoOiBcIlNIQS0yNTZcIixcbiAgICB9LCBrZXksIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShjb250ZW50KSk7XG4gICAgY29uc3Qgc2lnbmF0dXJlRGVyID0gY29udmVydEVjZHNhSWVlZTEzNjNUb0RlcihuZXcgVWludDhBcnJheShzaWduYXR1cmVJZWVlMTM2MykpO1xuICAgIHJldHVybiB1aW50OEFycmF5VG9IZXhTdHJpbmcoc2lnbmF0dXJlRGVyKTtcbn1cbi8qKlxuICogYFN1YnRsZUNyeXB0by5zaWduKC4uLilgIG91dHB1dHMgc2lnbmF0dXJlIGluIElFRUUgUDEzNjMgZm9ybWF0OlxuICogLSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU3VidGxlQ3J5cHRvL3NpZ24jZWNkc2FcbiAqXG4gKiBUdXJua2V5IGV4cGVjdHMgdGhlIHNpZ25hdHVyZSBlbmNvZGluZyB0byBiZSBERVItZW5jb2RlZCBBU04uMTpcbiAqIC0gaHR0cHM6Ly9naXRodWIuY29tL3RraHEvdGtjbGkvYmxvYi83ZjAxNTlhZjVhNzMzODdmZjA1MDY0NzE4MGQxZGI0ZDNhM2FhMDMzL3NyYy9pbnRlcm5hbC9hcGlrZXkvYXBpa2V5LmdvI0wxNDlcbiAqXG4gKiBDb2RlIG1vZGlmaWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS90aW5rL2Jsb2IvNmY3NGI5OWEyYmZlNjY3N2UzNjcwNzk5MTE2YTU3MjY4ZmQwNjdmYS9qYXZhc2NyaXB0L3N1YnRsZS9lbGxpcHRpY19jdXJ2ZXMudHMjTDExNFxuICpcbiAqIFRyYW5zZm9ybSBhbiBFQ0RTQSBzaWduYXR1cmUgaW4gSUVFRSAxMzYzIGVuY29kaW5nIHRvIERFUiBlbmNvZGluZy5cbiAqXG4gKiBAcGFyYW0gaWVlZSB0aGUgRUNEU0Egc2lnbmF0dXJlIGluIElFRUUgZW5jb2RpbmdcbiAqIEByZXR1cm4gRUNEU0Egc2lnbmF0dXJlIGluIERFUiBlbmNvZGluZ1xuICovXG5mdW5jdGlvbiBjb252ZXJ0RWNkc2FJZWVlMTM2M1RvRGVyKGllZWUpIHtcbiAgICBpZiAoaWVlZS5sZW5ndGggJSAyICE9IDAgfHwgaWVlZS5sZW5ndGggPT0gMCB8fCBpZWVlLmxlbmd0aCA+IDEzMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIElFRUUgUDEzNjMgc2lnbmF0dXJlIGVuY29kaW5nLiBMZW5ndGg6IFwiICsgaWVlZS5sZW5ndGgpO1xuICAgIH1cbiAgICBjb25zdCByID0gdG9VbnNpZ25lZEJpZ051bShpZWVlLnN1YmFycmF5KDAsIGllZWUubGVuZ3RoIC8gMikpO1xuICAgIGNvbnN0IHMgPSB0b1Vuc2lnbmVkQmlnTnVtKGllZWUuc3ViYXJyYXkoaWVlZS5sZW5ndGggLyAyLCBpZWVlLmxlbmd0aCkpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGNvbnN0IGxlbmd0aCA9IDEgKyAxICsgci5sZW5ndGggKyAxICsgMSArIHMubGVuZ3RoO1xuICAgIGxldCBkZXI7XG4gICAgaWYgKGxlbmd0aCA+PSAxMjgpIHtcbiAgICAgICAgZGVyID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoICsgMyk7XG4gICAgICAgIGRlcltvZmZzZXQrK10gPSA0ODtcbiAgICAgICAgZGVyW29mZnNldCsrXSA9IDEyOCArIDE7XG4gICAgICAgIGRlcltvZmZzZXQrK10gPSBsZW5ndGg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkZXIgPSBuZXcgVWludDhBcnJheShsZW5ndGggKyAyKTtcbiAgICAgICAgZGVyW29mZnNldCsrXSA9IDQ4O1xuICAgICAgICBkZXJbb2Zmc2V0KytdID0gbGVuZ3RoO1xuICAgIH1cbiAgICBkZXJbb2Zmc2V0KytdID0gMjtcbiAgICBkZXJbb2Zmc2V0KytdID0gci5sZW5ndGg7XG4gICAgZGVyLnNldChyLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSByLmxlbmd0aDtcbiAgICBkZXJbb2Zmc2V0KytdID0gMjtcbiAgICBkZXJbb2Zmc2V0KytdID0gcy5sZW5ndGg7XG4gICAgZGVyLnNldChzLCBvZmZzZXQpO1xuICAgIHJldHVybiBkZXI7XG59XG4vKipcbiAqIENvZGUgbW9kaWZpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL3RpbmsvYmxvYi82Zjc0Yjk5YTJiZmU2Njc3ZTM2NzA3OTkxMTZhNTcyNjhmZDA2N2ZhL2phdmFzY3JpcHQvc3VidGxlL2VsbGlwdGljX2N1cnZlcy50cyNMMzExXG4gKlxuICogVHJhbnNmb3JtIGEgYmlnIGludGVnZXIgaW4gYmlnIGVuZGlhbiB0byBtaW5pbWFsIHVuc2lnbmVkIGZvcm0gd2hpY2ggaGFzXG4gKiBubyBleHRyYSB6ZXJvIGF0IHRoZSBiZWdpbm5pbmcgZXhjZXB0IHdoZW4gdGhlIGhpZ2hlc3QgYml0IGlzIHNldC5cbiAqL1xuZnVuY3Rpb24gdG9VbnNpZ25lZEJpZ051bShieXRlcykge1xuICAgIC8vIFJlbW92ZSB6ZXJvIHByZWZpeGVzLlxuICAgIGxldCBzdGFydCA9IDA7XG4gICAgd2hpbGUgKHN0YXJ0IDwgYnl0ZXMubGVuZ3RoICYmIGJ5dGVzW3N0YXJ0XSA9PSAwKSB7XG4gICAgICAgIHN0YXJ0Kys7XG4gICAgfVxuICAgIGlmIChzdGFydCA9PSBieXRlcy5sZW5ndGgpIHtcbiAgICAgICAgc3RhcnQgPSBieXRlcy5sZW5ndGggLSAxO1xuICAgIH1cbiAgICBsZXQgZXh0cmFaZXJvID0gMDtcbiAgICAvLyBJZiB0aGUgMXN0IGJpdCBpcyBub3QgemVybywgYWRkIDEgemVybyBieXRlLlxuICAgIGlmICgoYnl0ZXNbc3RhcnRdICYgMTI4KSA9PSAxMjgpIHtcbiAgICAgICAgLy8gQWRkIGV4dHJhIHplcm8uXG4gICAgICAgIGV4dHJhWmVybyA9IDE7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KGJ5dGVzLmxlbmd0aCAtIHN0YXJ0ICsgZXh0cmFaZXJvKTtcbiAgICByZXMuc2V0KGJ5dGVzLnN1YmFycmF5KHN0YXJ0KSwgZXh0cmFaZXJvKTtcbiAgICByZXR1cm4gcmVzO1xufVxuXG5leHBvcnQgeyBzaWduV2l0aEFwaUtleSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViY3J5cHRvLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@turnkey/api-key-stamper/dist/webcrypto.mjs\n"));

/***/ })

}]);