"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/sturdy-websocket";
exports.ids = ["vendor-chunks/sturdy-websocket"];
exports.modules = {

/***/ "(ssr)/./node_modules/sturdy-websocket/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/sturdy-websocket/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar SHOULD_RECONNECT_FALSE_MESSAGE = \"Provided shouldReconnect() returned false. Closing permanently.\";\nvar SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE = \"Provided shouldReconnect() resolved to false. Closing permanently.\";\nvar SturdyWebSocket = /** @class */ (function () {\n    function SturdyWebSocket(url, protocolsOrOptions, options) {\n        if (options === void 0) { options = {}; }\n        this.url = url;\n        this.onclose = null;\n        this.onerror = null;\n        this.onmessage = null;\n        this.onopen = null;\n        this.ondown = null;\n        this.onreopen = null;\n        this.CONNECTING = SturdyWebSocket.CONNECTING;\n        this.OPEN = SturdyWebSocket.OPEN;\n        this.CLOSING = SturdyWebSocket.CLOSING;\n        this.CLOSED = SturdyWebSocket.CLOSED;\n        this.hasBeenOpened = false;\n        this.isClosed = false;\n        this.messageBuffer = [];\n        this.nextRetryTime = 0;\n        this.reconnectCount = 0;\n        this.lastKnownExtensions = \"\";\n        this.lastKnownProtocol = \"\";\n        this.listeners = {};\n        if (protocolsOrOptions == null ||\n            typeof protocolsOrOptions === \"string\" ||\n            Array.isArray(protocolsOrOptions)) {\n            this.protocols = protocolsOrOptions;\n        }\n        else {\n            options = protocolsOrOptions;\n        }\n        this.options = applyDefaultOptions(options);\n        if (!this.options.wsConstructor) {\n            if (typeof WebSocket !== \"undefined\") {\n                this.options.wsConstructor = WebSocket;\n            }\n            else {\n                throw new Error(\"WebSocket not present in global scope and no \" +\n                    \"wsConstructor option was provided.\");\n            }\n        }\n        this.openNewWebSocket();\n    }\n    Object.defineProperty(SturdyWebSocket.prototype, \"binaryType\", {\n        get: function () {\n            return this.binaryTypeInternal || \"blob\";\n        },\n        set: function (binaryType) {\n            this.binaryTypeInternal = binaryType;\n            if (this.ws) {\n                this.ws.binaryType = binaryType;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"bufferedAmount\", {\n        get: function () {\n            var sum = this.ws ? this.ws.bufferedAmount : 0;\n            var hasUnknownAmount = false;\n            this.messageBuffer.forEach(function (data) {\n                var byteLength = getDataByteLength(data);\n                if (byteLength != null) {\n                    sum += byteLength;\n                }\n                else {\n                    hasUnknownAmount = true;\n                }\n            });\n            if (hasUnknownAmount) {\n                this.debugLog(\"Some buffered data had unknown length. bufferedAmount()\" +\n                    \" return value may be below the correct amount.\");\n            }\n            return sum;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"extensions\", {\n        get: function () {\n            return this.ws ? this.ws.extensions : this.lastKnownExtensions;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"protocol\", {\n        get: function () {\n            return this.ws ? this.ws.protocol : this.lastKnownProtocol;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"readyState\", {\n        get: function () {\n            return this.isClosed ? SturdyWebSocket.CLOSED : SturdyWebSocket.OPEN;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SturdyWebSocket.prototype.close = function (code, reason) {\n        this.disposeSocket(code, reason);\n        this.shutdown();\n        this.debugLog(\"WebSocket permanently closed by client.\");\n    };\n    SturdyWebSocket.prototype.send = function (data) {\n        if (this.isClosed) {\n            throw new Error(\"WebSocket is already in CLOSING or CLOSED state.\");\n        }\n        else if (this.ws && this.ws.readyState === this.OPEN) {\n            this.ws.send(data);\n        }\n        else {\n            this.messageBuffer.push(data);\n        }\n    };\n    SturdyWebSocket.prototype.reconnect = function () {\n        if (this.isClosed) {\n            throw new Error(\"Cannot call reconnect() on socket which is permanently closed.\");\n        }\n        this.disposeSocket(1000, \"Client requested reconnect.\");\n        this.handleClose(undefined);\n    };\n    SturdyWebSocket.prototype.addEventListener = function (type, listener) {\n        if (!this.listeners[type]) {\n            this.listeners[type] = [];\n        }\n        this.listeners[type].push(listener);\n    };\n    SturdyWebSocket.prototype.dispatchEvent = function (event) {\n        return this.dispatchEventOfType(event.type, event);\n    };\n    SturdyWebSocket.prototype.removeEventListener = function (type, listener) {\n        if (this.listeners[type]) {\n            this.listeners[type] = this.listeners[type].filter(function (l) { return l !== listener; });\n        }\n    };\n    SturdyWebSocket.prototype.openNewWebSocket = function () {\n        var _this = this;\n        if (this.isClosed) {\n            return;\n        }\n        var _a = this.options, connectTimeout = _a.connectTimeout, wsConstructor = _a.wsConstructor;\n        this.debugLog(\"Opening new WebSocket to \" + this.url + \".\");\n        var ws = new wsConstructor(this.url, this.protocols);\n        ws.onclose = function (event) { return _this.handleClose(event); };\n        ws.onerror = function (event) { return _this.handleError(event); };\n        ws.onmessage = function (event) { return _this.handleMessage(event); };\n        ws.onopen = function (event) { return _this.handleOpen(event); };\n        this.connectTimeoutId = setTimeout(function () {\n            // If this is running, we still haven't opened the websocket.\n            // Kill it so we can try again.\n            _this.clearConnectTimeout();\n            _this.disposeSocket();\n            _this.handleClose(undefined);\n        }, connectTimeout);\n        this.ws = ws;\n    };\n    SturdyWebSocket.prototype.handleOpen = function (event) {\n        var _this = this;\n        if (!this.ws || this.isClosed) {\n            return;\n        }\n        var allClearResetTime = this.options.allClearResetTime;\n        this.debugLog(\"WebSocket opened.\");\n        if (this.binaryTypeInternal != null) {\n            this.ws.binaryType = this.binaryTypeInternal;\n        }\n        else {\n            this.binaryTypeInternal = this.ws.binaryType;\n        }\n        this.clearConnectTimeout();\n        if (this.hasBeenOpened) {\n            this.dispatchEventOfType(\"reopen\", event);\n        }\n        else {\n            this.dispatchEventOfType(\"open\", event);\n            this.hasBeenOpened = true;\n        }\n        this.messageBuffer.forEach(function (message) { return _this.send(message); });\n        this.messageBuffer = [];\n        this.allClearTimeoutId = setTimeout(function () {\n            _this.clearAllClearTimeout();\n            _this.nextRetryTime = 0;\n            _this.reconnectCount = 0;\n            var openTime = (allClearResetTime / 1000) | 0;\n            _this.debugLog(\"WebSocket remained open for \" + openTime + \" seconds. Resetting\" +\n                \" retry time and count.\");\n        }, allClearResetTime);\n    };\n    SturdyWebSocket.prototype.handleMessage = function (event) {\n        if (this.isClosed) {\n            return;\n        }\n        this.dispatchEventOfType(\"message\", event);\n    };\n    SturdyWebSocket.prototype.handleClose = function (event) {\n        var _this = this;\n        if (this.isClosed) {\n            return;\n        }\n        var _a = this.options, maxReconnectAttempts = _a.maxReconnectAttempts, shouldReconnect = _a.shouldReconnect;\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n        if (this.ws) {\n            this.lastKnownExtensions = this.ws.extensions;\n            this.lastKnownProtocol = this.ws.protocol;\n            this.disposeSocket();\n        }\n        this.dispatchEventOfType(\"down\", event);\n        if (this.reconnectCount >= maxReconnectAttempts) {\n            this.stopReconnecting(event, this.getTooManyFailedReconnectsMessage());\n            return;\n        }\n        var willReconnect = !event || shouldReconnect(event);\n        if (typeof willReconnect === \"boolean\") {\n            this.handleWillReconnect(willReconnect, event, SHOULD_RECONNECT_FALSE_MESSAGE);\n        }\n        else {\n            willReconnect.then(function (willReconnectResolved) {\n                if (_this.isClosed) {\n                    return;\n                }\n                _this.handleWillReconnect(willReconnectResolved, event, SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE);\n            });\n        }\n    };\n    SturdyWebSocket.prototype.handleError = function (event) {\n        this.dispatchEventOfType(\"error\", event);\n        this.debugLog(\"WebSocket encountered an error.\");\n    };\n    SturdyWebSocket.prototype.handleWillReconnect = function (willReconnect, event, denialReason) {\n        if (willReconnect) {\n            this.reestablishConnection();\n        }\n        else {\n            this.stopReconnecting(event, denialReason);\n        }\n    };\n    SturdyWebSocket.prototype.reestablishConnection = function () {\n        var _this = this;\n        var _a = this.options, minReconnectDelay = _a.minReconnectDelay, maxReconnectDelay = _a.maxReconnectDelay, reconnectBackoffFactor = _a.reconnectBackoffFactor;\n        this.reconnectCount++;\n        var retryTime = this.nextRetryTime;\n        this.nextRetryTime = Math.max(minReconnectDelay, Math.min(this.nextRetryTime * reconnectBackoffFactor, maxReconnectDelay));\n        setTimeout(function () { return _this.openNewWebSocket(); }, retryTime);\n        var retryTimeSeconds = (retryTime / 1000) | 0;\n        this.debugLog(\"WebSocket was closed. Re-opening in \" + retryTimeSeconds + \" seconds.\");\n    };\n    SturdyWebSocket.prototype.stopReconnecting = function (event, debugReason) {\n        this.debugLog(debugReason);\n        this.shutdown();\n        if (event) {\n            this.dispatchEventOfType(\"close\", event);\n        }\n    };\n    SturdyWebSocket.prototype.shutdown = function () {\n        this.isClosed = true;\n        this.clearAllTimeouts();\n        this.messageBuffer = [];\n        this.disposeSocket();\n    };\n    SturdyWebSocket.prototype.disposeSocket = function (closeCode, reason) {\n        if (!this.ws) {\n            return;\n        }\n        // Use noop handlers instead of null because some WebSocket\n        // implementations, such as the one from isomorphic-ws, raise a stink on\n        // unhandled events.\n        this.ws.onerror = noop;\n        this.ws.onclose = noop;\n        this.ws.onmessage = noop;\n        this.ws.onopen = noop;\n        this.ws.close(closeCode, reason);\n        this.ws = undefined;\n    };\n    SturdyWebSocket.prototype.clearAllTimeouts = function () {\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n    };\n    SturdyWebSocket.prototype.clearConnectTimeout = function () {\n        if (this.connectTimeoutId != null) {\n            clearTimeout(this.connectTimeoutId);\n            this.connectTimeoutId = undefined;\n        }\n    };\n    SturdyWebSocket.prototype.clearAllClearTimeout = function () {\n        if (this.allClearTimeoutId != null) {\n            clearTimeout(this.allClearTimeoutId);\n            this.allClearTimeoutId = undefined;\n        }\n    };\n    SturdyWebSocket.prototype.dispatchEventOfType = function (type, event) {\n        var _this = this;\n        switch (type) {\n            case \"close\":\n                if (this.onclose) {\n                    this.onclose(event);\n                }\n                break;\n            case \"error\":\n                if (this.onerror) {\n                    this.onerror(event);\n                }\n                break;\n            case \"message\":\n                if (this.onmessage) {\n                    this.onmessage(event);\n                }\n                break;\n            case \"open\":\n                if (this.onopen) {\n                    this.onopen(event);\n                }\n                break;\n            case \"down\":\n                if (this.ondown) {\n                    this.ondown(event);\n                }\n                break;\n            case \"reopen\":\n                if (this.onreopen) {\n                    this.onreopen(event);\n                }\n                break;\n        }\n        if (type in this.listeners) {\n            this.listeners[type]\n                .slice()\n                .forEach(function (listener) { return _this.callListener(listener, event); });\n        }\n        return !event || !event.defaultPrevented;\n    };\n    SturdyWebSocket.prototype.callListener = function (listener, event) {\n        if (typeof listener === \"function\") {\n            listener.call(this, event);\n        }\n        else {\n            listener.handleEvent.call(this, event);\n        }\n    };\n    SturdyWebSocket.prototype.debugLog = function (message) {\n        if (this.options.debug) {\n            // tslint:disable-next-line:no-console\n            console.log(message);\n        }\n    };\n    SturdyWebSocket.prototype.getTooManyFailedReconnectsMessage = function () {\n        var maxReconnectAttempts = this.options.maxReconnectAttempts;\n        return \"Failed to reconnect after \" + maxReconnectAttempts + \" \" + pluralize(\"attempt\", maxReconnectAttempts) + \". Closing permanently.\";\n    };\n    SturdyWebSocket.DEFAULT_OPTIONS = {\n        allClearResetTime: 5000,\n        connectTimeout: 5000,\n        debug: false,\n        minReconnectDelay: 1000,\n        maxReconnectDelay: 30000,\n        maxReconnectAttempts: Number.POSITIVE_INFINITY,\n        reconnectBackoffFactor: 1.5,\n        shouldReconnect: function () { return true; },\n        wsConstructor: undefined,\n    };\n    SturdyWebSocket.CONNECTING = 0;\n    SturdyWebSocket.OPEN = 1;\n    SturdyWebSocket.CLOSING = 2;\n    SturdyWebSocket.CLOSED = 3;\n    return SturdyWebSocket;\n}());\nexports[\"default\"] = SturdyWebSocket;\nfunction applyDefaultOptions(options) {\n    var result = {};\n    Object.keys(SturdyWebSocket.DEFAULT_OPTIONS).forEach(function (key) {\n        var value = options[key];\n        result[key] =\n            value === undefined\n                ? SturdyWebSocket.DEFAULT_OPTIONS[key]\n                : value;\n    });\n    return result;\n}\nfunction getDataByteLength(data) {\n    if (typeof data === \"string\") {\n        // UTF-16 strings use two bytes per character.\n        return 2 * data.length;\n    }\n    else if (data instanceof ArrayBuffer) {\n        return data.byteLength;\n    }\n    else if (data instanceof Blob) {\n        return data.size;\n    }\n    else {\n        return undefined;\n    }\n}\nfunction pluralize(s, n) {\n    return n === 1 ? s : s + \"s\";\n}\nfunction noop() {\n    // Nothing.\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3R1cmR5LXdlYnNvY2tldC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSx3QkFBd0I7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsd0NBQXdDO0FBQ3hDLDBDQUEwQztBQUMxQyx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsNkJBQTZCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtDQUFrQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDZDQUE2QztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGNBQWM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VtYmVkZGVkLWFjY291bnRzLXF1aWNrc3RhcnQvLi9ub2RlX21vZHVsZXMvc3R1cmR5LXdlYnNvY2tldC9kaXN0L2luZGV4LmpzP2VlZGEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgU0hPVUxEX1JFQ09OTkVDVF9GQUxTRV9NRVNTQUdFID0gXCJQcm92aWRlZCBzaG91bGRSZWNvbm5lY3QoKSByZXR1cm5lZCBmYWxzZS4gQ2xvc2luZyBwZXJtYW5lbnRseS5cIjtcbnZhciBTSE9VTERfUkVDT05ORUNUX1BST01JU0VfRkFMU0VfTUVTU0FHRSA9IFwiUHJvdmlkZWQgc2hvdWxkUmVjb25uZWN0KCkgcmVzb2x2ZWQgdG8gZmFsc2UuIENsb3NpbmcgcGVybWFuZW50bHkuXCI7XG52YXIgU3R1cmR5V2ViU29ja2V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0dXJkeVdlYlNvY2tldCh1cmwsIHByb3RvY29sc09yT3B0aW9ucywgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5vbmNsb3NlID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbm1lc3NhZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLm9ub3BlbiA9IG51bGw7XG4gICAgICAgIHRoaXMub25kb3duID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbnJlb3BlbiA9IG51bGw7XG4gICAgICAgIHRoaXMuQ09OTkVDVElORyA9IFN0dXJkeVdlYlNvY2tldC5DT05ORUNUSU5HO1xuICAgICAgICB0aGlzLk9QRU4gPSBTdHVyZHlXZWJTb2NrZXQuT1BFTjtcbiAgICAgICAgdGhpcy5DTE9TSU5HID0gU3R1cmR5V2ViU29ja2V0LkNMT1NJTkc7XG4gICAgICAgIHRoaXMuQ0xPU0VEID0gU3R1cmR5V2ViU29ja2V0LkNMT1NFRDtcbiAgICAgICAgdGhpcy5oYXNCZWVuT3BlbmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNDbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tZXNzYWdlQnVmZmVyID0gW107XG4gICAgICAgIHRoaXMubmV4dFJldHJ5VGltZSA9IDA7XG4gICAgICAgIHRoaXMucmVjb25uZWN0Q291bnQgPSAwO1xuICAgICAgICB0aGlzLmxhc3RLbm93bkV4dGVuc2lvbnMgPSBcIlwiO1xuICAgICAgICB0aGlzLmxhc3RLbm93blByb3RvY29sID0gXCJcIjtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgaWYgKHByb3RvY29sc09yT3B0aW9ucyA9PSBudWxsIHx8XG4gICAgICAgICAgICB0eXBlb2YgcHJvdG9jb2xzT3JPcHRpb25zID09PSBcInN0cmluZ1wiIHx8XG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHByb3RvY29sc09yT3B0aW9ucykpIHtcbiAgICAgICAgICAgIHRoaXMucHJvdG9jb2xzID0gcHJvdG9jb2xzT3JPcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHByb3RvY29sc09yT3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBhcHBseURlZmF1bHRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy53c0NvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIFdlYlNvY2tldCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy53c0NvbnN0cnVjdG9yID0gV2ViU29ja2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2ViU29ja2V0IG5vdCBwcmVzZW50IGluIGdsb2JhbCBzY29wZSBhbmQgbm8gXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIndzQ29uc3RydWN0b3Igb3B0aW9uIHdhcyBwcm92aWRlZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcGVuTmV3V2ViU29ja2V0KCk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLCBcImJpbmFyeVR5cGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJpbmFyeVR5cGVJbnRlcm5hbCB8fCBcImJsb2JcIjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoYmluYXJ5VHlwZSkge1xuICAgICAgICAgICAgdGhpcy5iaW5hcnlUeXBlSW50ZXJuYWwgPSBiaW5hcnlUeXBlO1xuICAgICAgICAgICAgaWYgKHRoaXMud3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSBiaW5hcnlUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZSwgXCJidWZmZXJlZEFtb3VudFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN1bSA9IHRoaXMud3MgPyB0aGlzLndzLmJ1ZmZlcmVkQW1vdW50IDogMDtcbiAgICAgICAgICAgIHZhciBoYXNVbmtub3duQW1vdW50ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VCdWZmZXIuZm9yRWFjaChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBieXRlTGVuZ3RoID0gZ2V0RGF0YUJ5dGVMZW5ndGgoZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKGJ5dGVMZW5ndGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc1Vua25vd25BbW91bnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGhhc1Vua25vd25BbW91bnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnTG9nKFwiU29tZSBidWZmZXJlZCBkYXRhIGhhZCB1bmtub3duIGxlbmd0aC4gYnVmZmVyZWRBbW91bnQoKVwiICtcbiAgICAgICAgICAgICAgICAgICAgXCIgcmV0dXJuIHZhbHVlIG1heSBiZSBiZWxvdyB0aGUgY29ycmVjdCBhbW91bnQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1bTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUsIFwiZXh0ZW5zaW9uc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud3MgPyB0aGlzLndzLmV4dGVuc2lvbnMgOiB0aGlzLmxhc3RLbm93bkV4dGVuc2lvbnM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLCBcInByb3RvY29sXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53cyA/IHRoaXMud3MucHJvdG9jb2wgOiB0aGlzLmxhc3RLbm93blByb3RvY29sO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZSwgXCJyZWFkeVN0YXRlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0Nsb3NlZCA/IFN0dXJkeVdlYlNvY2tldC5DTE9TRUQgOiBTdHVyZHlXZWJTb2NrZXQuT1BFTjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChjb2RlLCByZWFzb24pIHtcbiAgICAgICAgdGhpcy5kaXNwb3NlU29ja2V0KGNvZGUsIHJlYXNvbik7XG4gICAgICAgIHRoaXMuc2h1dGRvd24oKTtcbiAgICAgICAgdGhpcy5kZWJ1Z0xvZyhcIldlYlNvY2tldCBwZXJtYW5lbnRseSBjbG9zZWQgYnkgY2xpZW50LlwiKTtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZWJTb2NrZXQgaXMgYWxyZWFkeSBpbiBDTE9TSU5HIG9yIENMT1NFRCBzdGF0ZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy53cyAmJiB0aGlzLndzLnJlYWR5U3RhdGUgPT09IHRoaXMuT1BFTikge1xuICAgICAgICAgICAgdGhpcy53cy5zZW5kKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlQnVmZmVyLnB1c2goZGF0YSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUucmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgcmVjb25uZWN0KCkgb24gc29ja2V0IHdoaWNoIGlzIHBlcm1hbmVudGx5IGNsb3NlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNwb3NlU29ja2V0KDEwMDAsIFwiQ2xpZW50IHJlcXVlc3RlZCByZWNvbm5lY3QuXCIpO1xuICAgICAgICB0aGlzLmhhbmRsZUNsb3NlKHVuZGVmaW5lZCk7XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxpc3RlbmVyc1t0eXBlXSkge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaEV2ZW50T2ZUeXBlKGV2ZW50LnR5cGUsIGV2ZW50KTtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAodGhpcy5saXN0ZW5lcnNbdHlwZV0pIHtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdID0gdGhpcy5saXN0ZW5lcnNbdHlwZV0uZmlsdGVyKGZ1bmN0aW9uIChsKSB7IHJldHVybiBsICE9PSBsaXN0ZW5lcjsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUub3Blbk5ld1dlYlNvY2tldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSB0aGlzLm9wdGlvbnMsIGNvbm5lY3RUaW1lb3V0ID0gX2EuY29ubmVjdFRpbWVvdXQsIHdzQ29uc3RydWN0b3IgPSBfYS53c0NvbnN0cnVjdG9yO1xuICAgICAgICB0aGlzLmRlYnVnTG9nKFwiT3BlbmluZyBuZXcgV2ViU29ja2V0IHRvIFwiICsgdGhpcy51cmwgKyBcIi5cIik7XG4gICAgICAgIHZhciB3cyA9IG5ldyB3c0NvbnN0cnVjdG9yKHRoaXMudXJsLCB0aGlzLnByb3RvY29scyk7XG4gICAgICAgIHdzLm9uY2xvc2UgPSBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIF90aGlzLmhhbmRsZUNsb3NlKGV2ZW50KTsgfTtcbiAgICAgICAgd3Mub25lcnJvciA9IGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gX3RoaXMuaGFuZGxlRXJyb3IoZXZlbnQpOyB9O1xuICAgICAgICB3cy5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIF90aGlzLmhhbmRsZU1lc3NhZ2UoZXZlbnQpOyB9O1xuICAgICAgICB3cy5vbm9wZW4gPSBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIF90aGlzLmhhbmRsZU9wZW4oZXZlbnQpOyB9O1xuICAgICAgICB0aGlzLmNvbm5lY3RUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgcnVubmluZywgd2Ugc3RpbGwgaGF2ZW4ndCBvcGVuZWQgdGhlIHdlYnNvY2tldC5cbiAgICAgICAgICAgIC8vIEtpbGwgaXQgc28gd2UgY2FuIHRyeSBhZ2Fpbi5cbiAgICAgICAgICAgIF90aGlzLmNsZWFyQ29ubmVjdFRpbWVvdXQoKTtcbiAgICAgICAgICAgIF90aGlzLmRpc3Bvc2VTb2NrZXQoKTtcbiAgICAgICAgICAgIF90aGlzLmhhbmRsZUNsb3NlKHVuZGVmaW5lZCk7XG4gICAgICAgIH0sIGNvbm5lY3RUaW1lb3V0KTtcbiAgICAgICAgdGhpcy53cyA9IHdzO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5oYW5kbGVPcGVuID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy53cyB8fCB0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFsbENsZWFyUmVzZXRUaW1lID0gdGhpcy5vcHRpb25zLmFsbENsZWFyUmVzZXRUaW1lO1xuICAgICAgICB0aGlzLmRlYnVnTG9nKFwiV2ViU29ja2V0IG9wZW5lZC5cIik7XG4gICAgICAgIGlmICh0aGlzLmJpbmFyeVR5cGVJbnRlcm5hbCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSB0aGlzLmJpbmFyeVR5cGVJbnRlcm5hbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYmluYXJ5VHlwZUludGVybmFsID0gdGhpcy53cy5iaW5hcnlUeXBlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXJDb25uZWN0VGltZW91dCgpO1xuICAgICAgICBpZiAodGhpcy5oYXNCZWVuT3BlbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnRPZlR5cGUoXCJyZW9wZW5cIiwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50T2ZUeXBlKFwib3BlblwiLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLmhhc0JlZW5PcGVuZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVzc2FnZUJ1ZmZlci5mb3JFYWNoKGZ1bmN0aW9uIChtZXNzYWdlKSB7IHJldHVybiBfdGhpcy5zZW5kKG1lc3NhZ2UpOyB9KTtcbiAgICAgICAgdGhpcy5tZXNzYWdlQnVmZmVyID0gW107XG4gICAgICAgIHRoaXMuYWxsQ2xlYXJUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmNsZWFyQWxsQ2xlYXJUaW1lb3V0KCk7XG4gICAgICAgICAgICBfdGhpcy5uZXh0UmV0cnlUaW1lID0gMDtcbiAgICAgICAgICAgIF90aGlzLnJlY29ubmVjdENvdW50ID0gMDtcbiAgICAgICAgICAgIHZhciBvcGVuVGltZSA9IChhbGxDbGVhclJlc2V0VGltZSAvIDEwMDApIHwgMDtcbiAgICAgICAgICAgIF90aGlzLmRlYnVnTG9nKFwiV2ViU29ja2V0IHJlbWFpbmVkIG9wZW4gZm9yIFwiICsgb3BlblRpbWUgKyBcIiBzZWNvbmRzLiBSZXNldHRpbmdcIiArXG4gICAgICAgICAgICAgICAgXCIgcmV0cnkgdGltZSBhbmQgY291bnQuXCIpO1xuICAgICAgICB9LCBhbGxDbGVhclJlc2V0VGltZSk7XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmhhbmRsZU1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnRPZlR5cGUoXCJtZXNzYWdlXCIsIGV2ZW50KTtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuaGFuZGxlQ2xvc2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSB0aGlzLm9wdGlvbnMsIG1heFJlY29ubmVjdEF0dGVtcHRzID0gX2EubWF4UmVjb25uZWN0QXR0ZW1wdHMsIHNob3VsZFJlY29ubmVjdCA9IF9hLnNob3VsZFJlY29ubmVjdDtcbiAgICAgICAgdGhpcy5jbGVhckNvbm5lY3RUaW1lb3V0KCk7XG4gICAgICAgIHRoaXMuY2xlYXJBbGxDbGVhclRpbWVvdXQoKTtcbiAgICAgICAgaWYgKHRoaXMud3MpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdEtub3duRXh0ZW5zaW9ucyA9IHRoaXMud3MuZXh0ZW5zaW9ucztcbiAgICAgICAgICAgIHRoaXMubGFzdEtub3duUHJvdG9jb2wgPSB0aGlzLndzLnByb3RvY29sO1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlU29ja2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50T2ZUeXBlKFwiZG93blwiLCBldmVudCk7XG4gICAgICAgIGlmICh0aGlzLnJlY29ubmVjdENvdW50ID49IG1heFJlY29ubmVjdEF0dGVtcHRzKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BSZWNvbm5lY3RpbmcoZXZlbnQsIHRoaXMuZ2V0VG9vTWFueUZhaWxlZFJlY29ubmVjdHNNZXNzYWdlKCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aWxsUmVjb25uZWN0ID0gIWV2ZW50IHx8IHNob3VsZFJlY29ubmVjdChldmVudCk7XG4gICAgICAgIGlmICh0eXBlb2Ygd2lsbFJlY29ubmVjdCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlV2lsbFJlY29ubmVjdCh3aWxsUmVjb25uZWN0LCBldmVudCwgU0hPVUxEX1JFQ09OTkVDVF9GQUxTRV9NRVNTQUdFKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdpbGxSZWNvbm5lY3QudGhlbihmdW5jdGlvbiAod2lsbFJlY29ubmVjdFJlc29sdmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlV2lsbFJlY29ubmVjdCh3aWxsUmVjb25uZWN0UmVzb2x2ZWQsIGV2ZW50LCBTSE9VTERfUkVDT05ORUNUX1BST01JU0VfRkFMU0VfTUVTU0FHRSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5oYW5kbGVFcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnRPZlR5cGUoXCJlcnJvclwiLCBldmVudCk7XG4gICAgICAgIHRoaXMuZGVidWdMb2coXCJXZWJTb2NrZXQgZW5jb3VudGVyZWQgYW4gZXJyb3IuXCIpO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5oYW5kbGVXaWxsUmVjb25uZWN0ID0gZnVuY3Rpb24gKHdpbGxSZWNvbm5lY3QsIGV2ZW50LCBkZW5pYWxSZWFzb24pIHtcbiAgICAgICAgaWYgKHdpbGxSZWNvbm5lY3QpIHtcbiAgICAgICAgICAgIHRoaXMucmVlc3RhYmxpc2hDb25uZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BSZWNvbm5lY3RpbmcoZXZlbnQsIGRlbmlhbFJlYXNvbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUucmVlc3RhYmxpc2hDb25uZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLm9wdGlvbnMsIG1pblJlY29ubmVjdERlbGF5ID0gX2EubWluUmVjb25uZWN0RGVsYXksIG1heFJlY29ubmVjdERlbGF5ID0gX2EubWF4UmVjb25uZWN0RGVsYXksIHJlY29ubmVjdEJhY2tvZmZGYWN0b3IgPSBfYS5yZWNvbm5lY3RCYWNrb2ZmRmFjdG9yO1xuICAgICAgICB0aGlzLnJlY29ubmVjdENvdW50Kys7XG4gICAgICAgIHZhciByZXRyeVRpbWUgPSB0aGlzLm5leHRSZXRyeVRpbWU7XG4gICAgICAgIHRoaXMubmV4dFJldHJ5VGltZSA9IE1hdGgubWF4KG1pblJlY29ubmVjdERlbGF5LCBNYXRoLm1pbih0aGlzLm5leHRSZXRyeVRpbWUgKiByZWNvbm5lY3RCYWNrb2ZmRmFjdG9yLCBtYXhSZWNvbm5lY3REZWxheSkpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm9wZW5OZXdXZWJTb2NrZXQoKTsgfSwgcmV0cnlUaW1lKTtcbiAgICAgICAgdmFyIHJldHJ5VGltZVNlY29uZHMgPSAocmV0cnlUaW1lIC8gMTAwMCkgfCAwO1xuICAgICAgICB0aGlzLmRlYnVnTG9nKFwiV2ViU29ja2V0IHdhcyBjbG9zZWQuIFJlLW9wZW5pbmcgaW4gXCIgKyByZXRyeVRpbWVTZWNvbmRzICsgXCIgc2Vjb25kcy5cIik7XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLnN0b3BSZWNvbm5lY3RpbmcgPSBmdW5jdGlvbiAoZXZlbnQsIGRlYnVnUmVhc29uKSB7XG4gICAgICAgIHRoaXMuZGVidWdMb2coZGVidWdSZWFzb24pO1xuICAgICAgICB0aGlzLnNodXRkb3duKCk7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50T2ZUeXBlKFwiY2xvc2VcIiwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLnNodXRkb3duID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jbGVhckFsbFRpbWVvdXRzKCk7XG4gICAgICAgIHRoaXMubWVzc2FnZUJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLmRpc3Bvc2VTb2NrZXQoKTtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuZGlzcG9zZVNvY2tldCA9IGZ1bmN0aW9uIChjbG9zZUNvZGUsIHJlYXNvbikge1xuICAgICAgICBpZiAoIXRoaXMud3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2Ugbm9vcCBoYW5kbGVycyBpbnN0ZWFkIG9mIG51bGwgYmVjYXVzZSBzb21lIFdlYlNvY2tldFxuICAgICAgICAvLyBpbXBsZW1lbnRhdGlvbnMsIHN1Y2ggYXMgdGhlIG9uZSBmcm9tIGlzb21vcnBoaWMtd3MsIHJhaXNlIGEgc3Rpbmsgb25cbiAgICAgICAgLy8gdW5oYW5kbGVkIGV2ZW50cy5cbiAgICAgICAgdGhpcy53cy5vbmVycm9yID0gbm9vcDtcbiAgICAgICAgdGhpcy53cy5vbmNsb3NlID0gbm9vcDtcbiAgICAgICAgdGhpcy53cy5vbm1lc3NhZ2UgPSBub29wO1xuICAgICAgICB0aGlzLndzLm9ub3BlbiA9IG5vb3A7XG4gICAgICAgIHRoaXMud3MuY2xvc2UoY2xvc2VDb2RlLCByZWFzb24pO1xuICAgICAgICB0aGlzLndzID0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5jbGVhckFsbFRpbWVvdXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNsZWFyQ29ubmVjdFRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy5jbGVhckFsbENsZWFyVGltZW91dCgpO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5jbGVhckNvbm5lY3RUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0VGltZW91dElkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3RUaW1lb3V0SWQpO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0VGltZW91dElkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmNsZWFyQWxsQ2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5hbGxDbGVhclRpbWVvdXRJZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5hbGxDbGVhclRpbWVvdXRJZCk7XG4gICAgICAgICAgICB0aGlzLmFsbENsZWFyVGltZW91dElkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmRpc3BhdGNoRXZlbnRPZlR5cGUgPSBmdW5jdGlvbiAodHlwZSwgZXZlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiY2xvc2VcIjpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbmNsb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25jbG9zZShldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uZXJyb3IoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25tZXNzYWdlKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwib3BlblwiOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9ub3Blbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9ub3BlbihldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImRvd25cIjpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbmRvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbmRvd24oZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJyZW9wZW5cIjpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbnJlb3Blbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9ucmVvcGVuKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgaW4gdGhpcy5saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdXG4gICAgICAgICAgICAgICAgLnNsaWNlKClcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHsgcmV0dXJuIF90aGlzLmNhbGxMaXN0ZW5lcihsaXN0ZW5lciwgZXZlbnQpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIWV2ZW50IHx8ICFldmVudC5kZWZhdWx0UHJldmVudGVkO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5jYWxsTGlzdGVuZXIgPSBmdW5jdGlvbiAobGlzdGVuZXIsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsaXN0ZW5lci5oYW5kbGVFdmVudC5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5kZWJ1Z0xvZyA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5nZXRUb29NYW55RmFpbGVkUmVjb25uZWN0c01lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtYXhSZWNvbm5lY3RBdHRlbXB0cyA9IHRoaXMub3B0aW9ucy5tYXhSZWNvbm5lY3RBdHRlbXB0cztcbiAgICAgICAgcmV0dXJuIFwiRmFpbGVkIHRvIHJlY29ubmVjdCBhZnRlciBcIiArIG1heFJlY29ubmVjdEF0dGVtcHRzICsgXCIgXCIgKyBwbHVyYWxpemUoXCJhdHRlbXB0XCIsIG1heFJlY29ubmVjdEF0dGVtcHRzKSArIFwiLiBDbG9zaW5nIHBlcm1hbmVudGx5LlwiO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LkRFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICAgICAgYWxsQ2xlYXJSZXNldFRpbWU6IDUwMDAsXG4gICAgICAgIGNvbm5lY3RUaW1lb3V0OiA1MDAwLFxuICAgICAgICBkZWJ1ZzogZmFsc2UsXG4gICAgICAgIG1pblJlY29ubmVjdERlbGF5OiAxMDAwLFxuICAgICAgICBtYXhSZWNvbm5lY3REZWxheTogMzAwMDAsXG4gICAgICAgIG1heFJlY29ubmVjdEF0dGVtcHRzOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgICAgIHJlY29ubmVjdEJhY2tvZmZGYWN0b3I6IDEuNSxcbiAgICAgICAgc2hvdWxkUmVjb25uZWN0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAgICB3c0NvbnN0cnVjdG9yOiB1bmRlZmluZWQsXG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQuQ09OTkVDVElORyA9IDA7XG4gICAgU3R1cmR5V2ViU29ja2V0Lk9QRU4gPSAxO1xuICAgIFN0dXJkeVdlYlNvY2tldC5DTE9TSU5HID0gMjtcbiAgICBTdHVyZHlXZWJTb2NrZXQuQ0xPU0VEID0gMztcbiAgICByZXR1cm4gU3R1cmR5V2ViU29ja2V0O1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFN0dXJkeVdlYlNvY2tldDtcbmZ1bmN0aW9uIGFwcGx5RGVmYXVsdE9wdGlvbnMob3B0aW9ucykge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhTdHVyZHlXZWJTb2NrZXQuREVGQVVMVF9PUFRJT05TKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gb3B0aW9uc1trZXldO1xuICAgICAgICByZXN1bHRba2V5XSA9XG4gICAgICAgICAgICB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBTdHVyZHlXZWJTb2NrZXQuREVGQVVMVF9PUFRJT05TW2tleV1cbiAgICAgICAgICAgICAgICA6IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXREYXRhQnl0ZUxlbmd0aChkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIC8vIFVURi0xNiBzdHJpbmdzIHVzZSB0d28gYnl0ZXMgcGVyIGNoYXJhY3Rlci5cbiAgICAgICAgcmV0dXJuIDIgKiBkYXRhLmxlbmd0aDtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIHJldHVybiBkYXRhLnNpemU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBsdXJhbGl6ZShzLCBuKSB7XG4gICAgcmV0dXJuIG4gPT09IDEgPyBzIDogcyArIFwic1wiO1xufVxuZnVuY3Rpb24gbm9vcCgpIHtcbiAgICAvLyBOb3RoaW5nLlxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sturdy-websocket/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sturdy-websocket/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/sturdy-websocket/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar SHOULD_RECONNECT_FALSE_MESSAGE = \"Provided shouldReconnect() returned false. Closing permanently.\";\nvar SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE = \"Provided shouldReconnect() resolved to false. Closing permanently.\";\nvar SturdyWebSocket = /** @class */ (function () {\n    function SturdyWebSocket(url, protocolsOrOptions, options) {\n        if (options === void 0) { options = {}; }\n        this.url = url;\n        this.onclose = null;\n        this.onerror = null;\n        this.onmessage = null;\n        this.onopen = null;\n        this.ondown = null;\n        this.onreopen = null;\n        this.CONNECTING = SturdyWebSocket.CONNECTING;\n        this.OPEN = SturdyWebSocket.OPEN;\n        this.CLOSING = SturdyWebSocket.CLOSING;\n        this.CLOSED = SturdyWebSocket.CLOSED;\n        this.hasBeenOpened = false;\n        this.isClosed = false;\n        this.messageBuffer = [];\n        this.nextRetryTime = 0;\n        this.reconnectCount = 0;\n        this.lastKnownExtensions = \"\";\n        this.lastKnownProtocol = \"\";\n        this.listeners = {};\n        if (protocolsOrOptions == null ||\n            typeof protocolsOrOptions === \"string\" ||\n            Array.isArray(protocolsOrOptions)) {\n            this.protocols = protocolsOrOptions;\n        }\n        else {\n            options = protocolsOrOptions;\n        }\n        this.options = applyDefaultOptions(options);\n        if (!this.options.wsConstructor) {\n            if (typeof WebSocket !== \"undefined\") {\n                this.options.wsConstructor = WebSocket;\n            }\n            else {\n                throw new Error(\"WebSocket not present in global scope and no \" +\n                    \"wsConstructor option was provided.\");\n            }\n        }\n        this.openNewWebSocket();\n    }\n    Object.defineProperty(SturdyWebSocket.prototype, \"binaryType\", {\n        get: function () {\n            return this.binaryTypeInternal || \"blob\";\n        },\n        set: function (binaryType) {\n            this.binaryTypeInternal = binaryType;\n            if (this.ws) {\n                this.ws.binaryType = binaryType;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"bufferedAmount\", {\n        get: function () {\n            var sum = this.ws ? this.ws.bufferedAmount : 0;\n            var hasUnknownAmount = false;\n            this.messageBuffer.forEach(function (data) {\n                var byteLength = getDataByteLength(data);\n                if (byteLength != null) {\n                    sum += byteLength;\n                }\n                else {\n                    hasUnknownAmount = true;\n                }\n            });\n            if (hasUnknownAmount) {\n                this.debugLog(\"Some buffered data had unknown length. bufferedAmount()\" +\n                    \" return value may be below the correct amount.\");\n            }\n            return sum;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"extensions\", {\n        get: function () {\n            return this.ws ? this.ws.extensions : this.lastKnownExtensions;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"protocol\", {\n        get: function () {\n            return this.ws ? this.ws.protocol : this.lastKnownProtocol;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"readyState\", {\n        get: function () {\n            return this.isClosed ? SturdyWebSocket.CLOSED : SturdyWebSocket.OPEN;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SturdyWebSocket.prototype.close = function (code, reason) {\n        this.disposeSocket(code, reason);\n        this.shutdown();\n        this.debugLog(\"WebSocket permanently closed by client.\");\n    };\n    SturdyWebSocket.prototype.send = function (data) {\n        if (this.isClosed) {\n            throw new Error(\"WebSocket is already in CLOSING or CLOSED state.\");\n        }\n        else if (this.ws && this.ws.readyState === this.OPEN) {\n            this.ws.send(data);\n        }\n        else {\n            this.messageBuffer.push(data);\n        }\n    };\n    SturdyWebSocket.prototype.reconnect = function () {\n        if (this.isClosed) {\n            throw new Error(\"Cannot call reconnect() on socket which is permanently closed.\");\n        }\n        this.disposeSocket(1000, \"Client requested reconnect.\");\n        this.handleClose(undefined);\n    };\n    SturdyWebSocket.prototype.addEventListener = function (type, listener) {\n        if (!this.listeners[type]) {\n            this.listeners[type] = [];\n        }\n        this.listeners[type].push(listener);\n    };\n    SturdyWebSocket.prototype.dispatchEvent = function (event) {\n        return this.dispatchEventOfType(event.type, event);\n    };\n    SturdyWebSocket.prototype.removeEventListener = function (type, listener) {\n        if (this.listeners[type]) {\n            this.listeners[type] = this.listeners[type].filter(function (l) { return l !== listener; });\n        }\n    };\n    SturdyWebSocket.prototype.openNewWebSocket = function () {\n        var _this = this;\n        if (this.isClosed) {\n            return;\n        }\n        var _a = this.options, connectTimeout = _a.connectTimeout, wsConstructor = _a.wsConstructor;\n        this.debugLog(\"Opening new WebSocket to \" + this.url + \".\");\n        var ws = new wsConstructor(this.url, this.protocols);\n        ws.onclose = function (event) { return _this.handleClose(event); };\n        ws.onerror = function (event) { return _this.handleError(event); };\n        ws.onmessage = function (event) { return _this.handleMessage(event); };\n        ws.onopen = function (event) { return _this.handleOpen(event); };\n        this.connectTimeoutId = setTimeout(function () {\n            // If this is running, we still haven't opened the websocket.\n            // Kill it so we can try again.\n            _this.clearConnectTimeout();\n            _this.disposeSocket();\n            _this.handleClose(undefined);\n        }, connectTimeout);\n        this.ws = ws;\n    };\n    SturdyWebSocket.prototype.handleOpen = function (event) {\n        var _this = this;\n        if (!this.ws || this.isClosed) {\n            return;\n        }\n        var allClearResetTime = this.options.allClearResetTime;\n        this.debugLog(\"WebSocket opened.\");\n        if (this.binaryTypeInternal != null) {\n            this.ws.binaryType = this.binaryTypeInternal;\n        }\n        else {\n            this.binaryTypeInternal = this.ws.binaryType;\n        }\n        this.clearConnectTimeout();\n        if (this.hasBeenOpened) {\n            this.dispatchEventOfType(\"reopen\", event);\n        }\n        else {\n            this.dispatchEventOfType(\"open\", event);\n            this.hasBeenOpened = true;\n        }\n        this.messageBuffer.forEach(function (message) { return _this.send(message); });\n        this.messageBuffer = [];\n        this.allClearTimeoutId = setTimeout(function () {\n            _this.clearAllClearTimeout();\n            _this.nextRetryTime = 0;\n            _this.reconnectCount = 0;\n            var openTime = (allClearResetTime / 1000) | 0;\n            _this.debugLog(\"WebSocket remained open for \" + openTime + \" seconds. Resetting\" +\n                \" retry time and count.\");\n        }, allClearResetTime);\n    };\n    SturdyWebSocket.prototype.handleMessage = function (event) {\n        if (this.isClosed) {\n            return;\n        }\n        this.dispatchEventOfType(\"message\", event);\n    };\n    SturdyWebSocket.prototype.handleClose = function (event) {\n        var _this = this;\n        if (this.isClosed) {\n            return;\n        }\n        var _a = this.options, maxReconnectAttempts = _a.maxReconnectAttempts, shouldReconnect = _a.shouldReconnect;\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n        if (this.ws) {\n            this.lastKnownExtensions = this.ws.extensions;\n            this.lastKnownProtocol = this.ws.protocol;\n            this.disposeSocket();\n        }\n        this.dispatchEventOfType(\"down\", event);\n        if (this.reconnectCount >= maxReconnectAttempts) {\n            this.stopReconnecting(event, this.getTooManyFailedReconnectsMessage());\n            return;\n        }\n        var willReconnect = !event || shouldReconnect(event);\n        if (typeof willReconnect === \"boolean\") {\n            this.handleWillReconnect(willReconnect, event, SHOULD_RECONNECT_FALSE_MESSAGE);\n        }\n        else {\n            willReconnect.then(function (willReconnectResolved) {\n                if (_this.isClosed) {\n                    return;\n                }\n                _this.handleWillReconnect(willReconnectResolved, event, SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE);\n            });\n        }\n    };\n    SturdyWebSocket.prototype.handleError = function (event) {\n        this.dispatchEventOfType(\"error\", event);\n        this.debugLog(\"WebSocket encountered an error.\");\n    };\n    SturdyWebSocket.prototype.handleWillReconnect = function (willReconnect, event, denialReason) {\n        if (willReconnect) {\n            this.reestablishConnection();\n        }\n        else {\n            this.stopReconnecting(event, denialReason);\n        }\n    };\n    SturdyWebSocket.prototype.reestablishConnection = function () {\n        var _this = this;\n        var _a = this.options, minReconnectDelay = _a.minReconnectDelay, maxReconnectDelay = _a.maxReconnectDelay, reconnectBackoffFactor = _a.reconnectBackoffFactor;\n        this.reconnectCount++;\n        var retryTime = this.nextRetryTime;\n        this.nextRetryTime = Math.max(minReconnectDelay, Math.min(this.nextRetryTime * reconnectBackoffFactor, maxReconnectDelay));\n        setTimeout(function () { return _this.openNewWebSocket(); }, retryTime);\n        var retryTimeSeconds = (retryTime / 1000) | 0;\n        this.debugLog(\"WebSocket was closed. Re-opening in \" + retryTimeSeconds + \" seconds.\");\n    };\n    SturdyWebSocket.prototype.stopReconnecting = function (event, debugReason) {\n        this.debugLog(debugReason);\n        this.shutdown();\n        if (event) {\n            this.dispatchEventOfType(\"close\", event);\n        }\n    };\n    SturdyWebSocket.prototype.shutdown = function () {\n        this.isClosed = true;\n        this.clearAllTimeouts();\n        this.messageBuffer = [];\n        this.disposeSocket();\n    };\n    SturdyWebSocket.prototype.disposeSocket = function (closeCode, reason) {\n        if (!this.ws) {\n            return;\n        }\n        // Use noop handlers instead of null because some WebSocket\n        // implementations, such as the one from isomorphic-ws, raise a stink on\n        // unhandled events.\n        this.ws.onerror = noop;\n        this.ws.onclose = noop;\n        this.ws.onmessage = noop;\n        this.ws.onopen = noop;\n        this.ws.close(closeCode, reason);\n        this.ws = undefined;\n    };\n    SturdyWebSocket.prototype.clearAllTimeouts = function () {\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n    };\n    SturdyWebSocket.prototype.clearConnectTimeout = function () {\n        if (this.connectTimeoutId != null) {\n            clearTimeout(this.connectTimeoutId);\n            this.connectTimeoutId = undefined;\n        }\n    };\n    SturdyWebSocket.prototype.clearAllClearTimeout = function () {\n        if (this.allClearTimeoutId != null) {\n            clearTimeout(this.allClearTimeoutId);\n            this.allClearTimeoutId = undefined;\n        }\n    };\n    SturdyWebSocket.prototype.dispatchEventOfType = function (type, event) {\n        var _this = this;\n        switch (type) {\n            case \"close\":\n                if (this.onclose) {\n                    this.onclose(event);\n                }\n                break;\n            case \"error\":\n                if (this.onerror) {\n                    this.onerror(event);\n                }\n                break;\n            case \"message\":\n                if (this.onmessage) {\n                    this.onmessage(event);\n                }\n                break;\n            case \"open\":\n                if (this.onopen) {\n                    this.onopen(event);\n                }\n                break;\n            case \"down\":\n                if (this.ondown) {\n                    this.ondown(event);\n                }\n                break;\n            case \"reopen\":\n                if (this.onreopen) {\n                    this.onreopen(event);\n                }\n                break;\n        }\n        if (type in this.listeners) {\n            this.listeners[type]\n                .slice()\n                .forEach(function (listener) { return _this.callListener(listener, event); });\n        }\n        return !event || !event.defaultPrevented;\n    };\n    SturdyWebSocket.prototype.callListener = function (listener, event) {\n        if (typeof listener === \"function\") {\n            listener.call(this, event);\n        }\n        else {\n            listener.handleEvent.call(this, event);\n        }\n    };\n    SturdyWebSocket.prototype.debugLog = function (message) {\n        if (this.options.debug) {\n            // tslint:disable-next-line:no-console\n            console.log(message);\n        }\n    };\n    SturdyWebSocket.prototype.getTooManyFailedReconnectsMessage = function () {\n        var maxReconnectAttempts = this.options.maxReconnectAttempts;\n        return \"Failed to reconnect after \" + maxReconnectAttempts + \" \" + pluralize(\"attempt\", maxReconnectAttempts) + \". Closing permanently.\";\n    };\n    SturdyWebSocket.DEFAULT_OPTIONS = {\n        allClearResetTime: 5000,\n        connectTimeout: 5000,\n        debug: false,\n        minReconnectDelay: 1000,\n        maxReconnectDelay: 30000,\n        maxReconnectAttempts: Number.POSITIVE_INFINITY,\n        reconnectBackoffFactor: 1.5,\n        shouldReconnect: function () { return true; },\n        wsConstructor: undefined,\n    };\n    SturdyWebSocket.CONNECTING = 0;\n    SturdyWebSocket.OPEN = 1;\n    SturdyWebSocket.CLOSING = 2;\n    SturdyWebSocket.CLOSED = 3;\n    return SturdyWebSocket;\n}());\nexports[\"default\"] = SturdyWebSocket;\nfunction applyDefaultOptions(options) {\n    var result = {};\n    Object.keys(SturdyWebSocket.DEFAULT_OPTIONS).forEach(function (key) {\n        var value = options[key];\n        result[key] =\n            value === undefined\n                ? SturdyWebSocket.DEFAULT_OPTIONS[key]\n                : value;\n    });\n    return result;\n}\nfunction getDataByteLength(data) {\n    if (typeof data === \"string\") {\n        // UTF-16 strings use two bytes per character.\n        return 2 * data.length;\n    }\n    else if (data instanceof ArrayBuffer) {\n        return data.byteLength;\n    }\n    else if (data instanceof Blob) {\n        return data.size;\n    }\n    else {\n        return undefined;\n    }\n}\nfunction pluralize(s, n) {\n    return n === 1 ? s : s + \"s\";\n}\nfunction noop() {\n    // Nothing.\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3R1cmR5LXdlYnNvY2tldC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSx3QkFBd0I7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsd0NBQXdDO0FBQ3hDLDBDQUEwQztBQUMxQyx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsNkJBQTZCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtDQUFrQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDZDQUE2QztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGNBQWM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VtYmVkZGVkLWFjY291bnRzLXF1aWNrc3RhcnQvLi9ub2RlX21vZHVsZXMvc3R1cmR5LXdlYnNvY2tldC9kaXN0L2luZGV4LmpzP2MyOGEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgU0hPVUxEX1JFQ09OTkVDVF9GQUxTRV9NRVNTQUdFID0gXCJQcm92aWRlZCBzaG91bGRSZWNvbm5lY3QoKSByZXR1cm5lZCBmYWxzZS4gQ2xvc2luZyBwZXJtYW5lbnRseS5cIjtcbnZhciBTSE9VTERfUkVDT05ORUNUX1BST01JU0VfRkFMU0VfTUVTU0FHRSA9IFwiUHJvdmlkZWQgc2hvdWxkUmVjb25uZWN0KCkgcmVzb2x2ZWQgdG8gZmFsc2UuIENsb3NpbmcgcGVybWFuZW50bHkuXCI7XG52YXIgU3R1cmR5V2ViU29ja2V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0dXJkeVdlYlNvY2tldCh1cmwsIHByb3RvY29sc09yT3B0aW9ucywgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5vbmNsb3NlID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbm1lc3NhZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLm9ub3BlbiA9IG51bGw7XG4gICAgICAgIHRoaXMub25kb3duID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbnJlb3BlbiA9IG51bGw7XG4gICAgICAgIHRoaXMuQ09OTkVDVElORyA9IFN0dXJkeVdlYlNvY2tldC5DT05ORUNUSU5HO1xuICAgICAgICB0aGlzLk9QRU4gPSBTdHVyZHlXZWJTb2NrZXQuT1BFTjtcbiAgICAgICAgdGhpcy5DTE9TSU5HID0gU3R1cmR5V2ViU29ja2V0LkNMT1NJTkc7XG4gICAgICAgIHRoaXMuQ0xPU0VEID0gU3R1cmR5V2ViU29ja2V0LkNMT1NFRDtcbiAgICAgICAgdGhpcy5oYXNCZWVuT3BlbmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNDbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tZXNzYWdlQnVmZmVyID0gW107XG4gICAgICAgIHRoaXMubmV4dFJldHJ5VGltZSA9IDA7XG4gICAgICAgIHRoaXMucmVjb25uZWN0Q291bnQgPSAwO1xuICAgICAgICB0aGlzLmxhc3RLbm93bkV4dGVuc2lvbnMgPSBcIlwiO1xuICAgICAgICB0aGlzLmxhc3RLbm93blByb3RvY29sID0gXCJcIjtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgaWYgKHByb3RvY29sc09yT3B0aW9ucyA9PSBudWxsIHx8XG4gICAgICAgICAgICB0eXBlb2YgcHJvdG9jb2xzT3JPcHRpb25zID09PSBcInN0cmluZ1wiIHx8XG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHByb3RvY29sc09yT3B0aW9ucykpIHtcbiAgICAgICAgICAgIHRoaXMucHJvdG9jb2xzID0gcHJvdG9jb2xzT3JPcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHByb3RvY29sc09yT3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBhcHBseURlZmF1bHRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy53c0NvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIFdlYlNvY2tldCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy53c0NvbnN0cnVjdG9yID0gV2ViU29ja2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2ViU29ja2V0IG5vdCBwcmVzZW50IGluIGdsb2JhbCBzY29wZSBhbmQgbm8gXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIndzQ29uc3RydWN0b3Igb3B0aW9uIHdhcyBwcm92aWRlZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcGVuTmV3V2ViU29ja2V0KCk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLCBcImJpbmFyeVR5cGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJpbmFyeVR5cGVJbnRlcm5hbCB8fCBcImJsb2JcIjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoYmluYXJ5VHlwZSkge1xuICAgICAgICAgICAgdGhpcy5iaW5hcnlUeXBlSW50ZXJuYWwgPSBiaW5hcnlUeXBlO1xuICAgICAgICAgICAgaWYgKHRoaXMud3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSBiaW5hcnlUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZSwgXCJidWZmZXJlZEFtb3VudFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN1bSA9IHRoaXMud3MgPyB0aGlzLndzLmJ1ZmZlcmVkQW1vdW50IDogMDtcbiAgICAgICAgICAgIHZhciBoYXNVbmtub3duQW1vdW50ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VCdWZmZXIuZm9yRWFjaChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBieXRlTGVuZ3RoID0gZ2V0RGF0YUJ5dGVMZW5ndGgoZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKGJ5dGVMZW5ndGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc1Vua25vd25BbW91bnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGhhc1Vua25vd25BbW91bnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnTG9nKFwiU29tZSBidWZmZXJlZCBkYXRhIGhhZCB1bmtub3duIGxlbmd0aC4gYnVmZmVyZWRBbW91bnQoKVwiICtcbiAgICAgICAgICAgICAgICAgICAgXCIgcmV0dXJuIHZhbHVlIG1heSBiZSBiZWxvdyB0aGUgY29ycmVjdCBhbW91bnQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1bTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUsIFwiZXh0ZW5zaW9uc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud3MgPyB0aGlzLndzLmV4dGVuc2lvbnMgOiB0aGlzLmxhc3RLbm93bkV4dGVuc2lvbnM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLCBcInByb3RvY29sXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53cyA/IHRoaXMud3MucHJvdG9jb2wgOiB0aGlzLmxhc3RLbm93blByb3RvY29sO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZSwgXCJyZWFkeVN0YXRlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0Nsb3NlZCA/IFN0dXJkeVdlYlNvY2tldC5DTE9TRUQgOiBTdHVyZHlXZWJTb2NrZXQuT1BFTjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChjb2RlLCByZWFzb24pIHtcbiAgICAgICAgdGhpcy5kaXNwb3NlU29ja2V0KGNvZGUsIHJlYXNvbik7XG4gICAgICAgIHRoaXMuc2h1dGRvd24oKTtcbiAgICAgICAgdGhpcy5kZWJ1Z0xvZyhcIldlYlNvY2tldCBwZXJtYW5lbnRseSBjbG9zZWQgYnkgY2xpZW50LlwiKTtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZWJTb2NrZXQgaXMgYWxyZWFkeSBpbiBDTE9TSU5HIG9yIENMT1NFRCBzdGF0ZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy53cyAmJiB0aGlzLndzLnJlYWR5U3RhdGUgPT09IHRoaXMuT1BFTikge1xuICAgICAgICAgICAgdGhpcy53cy5zZW5kKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlQnVmZmVyLnB1c2goZGF0YSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUucmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgcmVjb25uZWN0KCkgb24gc29ja2V0IHdoaWNoIGlzIHBlcm1hbmVudGx5IGNsb3NlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNwb3NlU29ja2V0KDEwMDAsIFwiQ2xpZW50IHJlcXVlc3RlZCByZWNvbm5lY3QuXCIpO1xuICAgICAgICB0aGlzLmhhbmRsZUNsb3NlKHVuZGVmaW5lZCk7XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxpc3RlbmVyc1t0eXBlXSkge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaEV2ZW50T2ZUeXBlKGV2ZW50LnR5cGUsIGV2ZW50KTtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAodGhpcy5saXN0ZW5lcnNbdHlwZV0pIHtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdID0gdGhpcy5saXN0ZW5lcnNbdHlwZV0uZmlsdGVyKGZ1bmN0aW9uIChsKSB7IHJldHVybiBsICE9PSBsaXN0ZW5lcjsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUub3Blbk5ld1dlYlNvY2tldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSB0aGlzLm9wdGlvbnMsIGNvbm5lY3RUaW1lb3V0ID0gX2EuY29ubmVjdFRpbWVvdXQsIHdzQ29uc3RydWN0b3IgPSBfYS53c0NvbnN0cnVjdG9yO1xuICAgICAgICB0aGlzLmRlYnVnTG9nKFwiT3BlbmluZyBuZXcgV2ViU29ja2V0IHRvIFwiICsgdGhpcy51cmwgKyBcIi5cIik7XG4gICAgICAgIHZhciB3cyA9IG5ldyB3c0NvbnN0cnVjdG9yKHRoaXMudXJsLCB0aGlzLnByb3RvY29scyk7XG4gICAgICAgIHdzLm9uY2xvc2UgPSBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIF90aGlzLmhhbmRsZUNsb3NlKGV2ZW50KTsgfTtcbiAgICAgICAgd3Mub25lcnJvciA9IGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gX3RoaXMuaGFuZGxlRXJyb3IoZXZlbnQpOyB9O1xuICAgICAgICB3cy5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIF90aGlzLmhhbmRsZU1lc3NhZ2UoZXZlbnQpOyB9O1xuICAgICAgICB3cy5vbm9wZW4gPSBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIF90aGlzLmhhbmRsZU9wZW4oZXZlbnQpOyB9O1xuICAgICAgICB0aGlzLmNvbm5lY3RUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgcnVubmluZywgd2Ugc3RpbGwgaGF2ZW4ndCBvcGVuZWQgdGhlIHdlYnNvY2tldC5cbiAgICAgICAgICAgIC8vIEtpbGwgaXQgc28gd2UgY2FuIHRyeSBhZ2Fpbi5cbiAgICAgICAgICAgIF90aGlzLmNsZWFyQ29ubmVjdFRpbWVvdXQoKTtcbiAgICAgICAgICAgIF90aGlzLmRpc3Bvc2VTb2NrZXQoKTtcbiAgICAgICAgICAgIF90aGlzLmhhbmRsZUNsb3NlKHVuZGVmaW5lZCk7XG4gICAgICAgIH0sIGNvbm5lY3RUaW1lb3V0KTtcbiAgICAgICAgdGhpcy53cyA9IHdzO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5oYW5kbGVPcGVuID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy53cyB8fCB0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFsbENsZWFyUmVzZXRUaW1lID0gdGhpcy5vcHRpb25zLmFsbENsZWFyUmVzZXRUaW1lO1xuICAgICAgICB0aGlzLmRlYnVnTG9nKFwiV2ViU29ja2V0IG9wZW5lZC5cIik7XG4gICAgICAgIGlmICh0aGlzLmJpbmFyeVR5cGVJbnRlcm5hbCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSB0aGlzLmJpbmFyeVR5cGVJbnRlcm5hbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYmluYXJ5VHlwZUludGVybmFsID0gdGhpcy53cy5iaW5hcnlUeXBlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXJDb25uZWN0VGltZW91dCgpO1xuICAgICAgICBpZiAodGhpcy5oYXNCZWVuT3BlbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnRPZlR5cGUoXCJyZW9wZW5cIiwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50T2ZUeXBlKFwib3BlblwiLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLmhhc0JlZW5PcGVuZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVzc2FnZUJ1ZmZlci5mb3JFYWNoKGZ1bmN0aW9uIChtZXNzYWdlKSB7IHJldHVybiBfdGhpcy5zZW5kKG1lc3NhZ2UpOyB9KTtcbiAgICAgICAgdGhpcy5tZXNzYWdlQnVmZmVyID0gW107XG4gICAgICAgIHRoaXMuYWxsQ2xlYXJUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmNsZWFyQWxsQ2xlYXJUaW1lb3V0KCk7XG4gICAgICAgICAgICBfdGhpcy5uZXh0UmV0cnlUaW1lID0gMDtcbiAgICAgICAgICAgIF90aGlzLnJlY29ubmVjdENvdW50ID0gMDtcbiAgICAgICAgICAgIHZhciBvcGVuVGltZSA9IChhbGxDbGVhclJlc2V0VGltZSAvIDEwMDApIHwgMDtcbiAgICAgICAgICAgIF90aGlzLmRlYnVnTG9nKFwiV2ViU29ja2V0IHJlbWFpbmVkIG9wZW4gZm9yIFwiICsgb3BlblRpbWUgKyBcIiBzZWNvbmRzLiBSZXNldHRpbmdcIiArXG4gICAgICAgICAgICAgICAgXCIgcmV0cnkgdGltZSBhbmQgY291bnQuXCIpO1xuICAgICAgICB9LCBhbGxDbGVhclJlc2V0VGltZSk7XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmhhbmRsZU1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnRPZlR5cGUoXCJtZXNzYWdlXCIsIGV2ZW50KTtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuaGFuZGxlQ2xvc2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSB0aGlzLm9wdGlvbnMsIG1heFJlY29ubmVjdEF0dGVtcHRzID0gX2EubWF4UmVjb25uZWN0QXR0ZW1wdHMsIHNob3VsZFJlY29ubmVjdCA9IF9hLnNob3VsZFJlY29ubmVjdDtcbiAgICAgICAgdGhpcy5jbGVhckNvbm5lY3RUaW1lb3V0KCk7XG4gICAgICAgIHRoaXMuY2xlYXJBbGxDbGVhclRpbWVvdXQoKTtcbiAgICAgICAgaWYgKHRoaXMud3MpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdEtub3duRXh0ZW5zaW9ucyA9IHRoaXMud3MuZXh0ZW5zaW9ucztcbiAgICAgICAgICAgIHRoaXMubGFzdEtub3duUHJvdG9jb2wgPSB0aGlzLndzLnByb3RvY29sO1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlU29ja2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50T2ZUeXBlKFwiZG93blwiLCBldmVudCk7XG4gICAgICAgIGlmICh0aGlzLnJlY29ubmVjdENvdW50ID49IG1heFJlY29ubmVjdEF0dGVtcHRzKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BSZWNvbm5lY3RpbmcoZXZlbnQsIHRoaXMuZ2V0VG9vTWFueUZhaWxlZFJlY29ubmVjdHNNZXNzYWdlKCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aWxsUmVjb25uZWN0ID0gIWV2ZW50IHx8IHNob3VsZFJlY29ubmVjdChldmVudCk7XG4gICAgICAgIGlmICh0eXBlb2Ygd2lsbFJlY29ubmVjdCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlV2lsbFJlY29ubmVjdCh3aWxsUmVjb25uZWN0LCBldmVudCwgU0hPVUxEX1JFQ09OTkVDVF9GQUxTRV9NRVNTQUdFKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdpbGxSZWNvbm5lY3QudGhlbihmdW5jdGlvbiAod2lsbFJlY29ubmVjdFJlc29sdmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlV2lsbFJlY29ubmVjdCh3aWxsUmVjb25uZWN0UmVzb2x2ZWQsIGV2ZW50LCBTSE9VTERfUkVDT05ORUNUX1BST01JU0VfRkFMU0VfTUVTU0FHRSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5oYW5kbGVFcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnRPZlR5cGUoXCJlcnJvclwiLCBldmVudCk7XG4gICAgICAgIHRoaXMuZGVidWdMb2coXCJXZWJTb2NrZXQgZW5jb3VudGVyZWQgYW4gZXJyb3IuXCIpO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5oYW5kbGVXaWxsUmVjb25uZWN0ID0gZnVuY3Rpb24gKHdpbGxSZWNvbm5lY3QsIGV2ZW50LCBkZW5pYWxSZWFzb24pIHtcbiAgICAgICAgaWYgKHdpbGxSZWNvbm5lY3QpIHtcbiAgICAgICAgICAgIHRoaXMucmVlc3RhYmxpc2hDb25uZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BSZWNvbm5lY3RpbmcoZXZlbnQsIGRlbmlhbFJlYXNvbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUucmVlc3RhYmxpc2hDb25uZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLm9wdGlvbnMsIG1pblJlY29ubmVjdERlbGF5ID0gX2EubWluUmVjb25uZWN0RGVsYXksIG1heFJlY29ubmVjdERlbGF5ID0gX2EubWF4UmVjb25uZWN0RGVsYXksIHJlY29ubmVjdEJhY2tvZmZGYWN0b3IgPSBfYS5yZWNvbm5lY3RCYWNrb2ZmRmFjdG9yO1xuICAgICAgICB0aGlzLnJlY29ubmVjdENvdW50Kys7XG4gICAgICAgIHZhciByZXRyeVRpbWUgPSB0aGlzLm5leHRSZXRyeVRpbWU7XG4gICAgICAgIHRoaXMubmV4dFJldHJ5VGltZSA9IE1hdGgubWF4KG1pblJlY29ubmVjdERlbGF5LCBNYXRoLm1pbih0aGlzLm5leHRSZXRyeVRpbWUgKiByZWNvbm5lY3RCYWNrb2ZmRmFjdG9yLCBtYXhSZWNvbm5lY3REZWxheSkpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm9wZW5OZXdXZWJTb2NrZXQoKTsgfSwgcmV0cnlUaW1lKTtcbiAgICAgICAgdmFyIHJldHJ5VGltZVNlY29uZHMgPSAocmV0cnlUaW1lIC8gMTAwMCkgfCAwO1xuICAgICAgICB0aGlzLmRlYnVnTG9nKFwiV2ViU29ja2V0IHdhcyBjbG9zZWQuIFJlLW9wZW5pbmcgaW4gXCIgKyByZXRyeVRpbWVTZWNvbmRzICsgXCIgc2Vjb25kcy5cIik7XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLnN0b3BSZWNvbm5lY3RpbmcgPSBmdW5jdGlvbiAoZXZlbnQsIGRlYnVnUmVhc29uKSB7XG4gICAgICAgIHRoaXMuZGVidWdMb2coZGVidWdSZWFzb24pO1xuICAgICAgICB0aGlzLnNodXRkb3duKCk7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50T2ZUeXBlKFwiY2xvc2VcIiwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLnNodXRkb3duID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jbGVhckFsbFRpbWVvdXRzKCk7XG4gICAgICAgIHRoaXMubWVzc2FnZUJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLmRpc3Bvc2VTb2NrZXQoKTtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuZGlzcG9zZVNvY2tldCA9IGZ1bmN0aW9uIChjbG9zZUNvZGUsIHJlYXNvbikge1xuICAgICAgICBpZiAoIXRoaXMud3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2Ugbm9vcCBoYW5kbGVycyBpbnN0ZWFkIG9mIG51bGwgYmVjYXVzZSBzb21lIFdlYlNvY2tldFxuICAgICAgICAvLyBpbXBsZW1lbnRhdGlvbnMsIHN1Y2ggYXMgdGhlIG9uZSBmcm9tIGlzb21vcnBoaWMtd3MsIHJhaXNlIGEgc3Rpbmsgb25cbiAgICAgICAgLy8gdW5oYW5kbGVkIGV2ZW50cy5cbiAgICAgICAgdGhpcy53cy5vbmVycm9yID0gbm9vcDtcbiAgICAgICAgdGhpcy53cy5vbmNsb3NlID0gbm9vcDtcbiAgICAgICAgdGhpcy53cy5vbm1lc3NhZ2UgPSBub29wO1xuICAgICAgICB0aGlzLndzLm9ub3BlbiA9IG5vb3A7XG4gICAgICAgIHRoaXMud3MuY2xvc2UoY2xvc2VDb2RlLCByZWFzb24pO1xuICAgICAgICB0aGlzLndzID0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5jbGVhckFsbFRpbWVvdXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNsZWFyQ29ubmVjdFRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy5jbGVhckFsbENsZWFyVGltZW91dCgpO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5jbGVhckNvbm5lY3RUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0VGltZW91dElkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3RUaW1lb3V0SWQpO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0VGltZW91dElkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmNsZWFyQWxsQ2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5hbGxDbGVhclRpbWVvdXRJZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5hbGxDbGVhclRpbWVvdXRJZCk7XG4gICAgICAgICAgICB0aGlzLmFsbENsZWFyVGltZW91dElkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmRpc3BhdGNoRXZlbnRPZlR5cGUgPSBmdW5jdGlvbiAodHlwZSwgZXZlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiY2xvc2VcIjpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbmNsb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25jbG9zZShldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uZXJyb3IoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25tZXNzYWdlKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwib3BlblwiOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9ub3Blbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9ub3BlbihldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImRvd25cIjpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbmRvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbmRvd24oZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJyZW9wZW5cIjpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbnJlb3Blbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9ucmVvcGVuKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgaW4gdGhpcy5saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdXG4gICAgICAgICAgICAgICAgLnNsaWNlKClcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHsgcmV0dXJuIF90aGlzLmNhbGxMaXN0ZW5lcihsaXN0ZW5lciwgZXZlbnQpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIWV2ZW50IHx8ICFldmVudC5kZWZhdWx0UHJldmVudGVkO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5jYWxsTGlzdGVuZXIgPSBmdW5jdGlvbiAobGlzdGVuZXIsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsaXN0ZW5lci5oYW5kbGVFdmVudC5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5kZWJ1Z0xvZyA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5nZXRUb29NYW55RmFpbGVkUmVjb25uZWN0c01lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtYXhSZWNvbm5lY3RBdHRlbXB0cyA9IHRoaXMub3B0aW9ucy5tYXhSZWNvbm5lY3RBdHRlbXB0cztcbiAgICAgICAgcmV0dXJuIFwiRmFpbGVkIHRvIHJlY29ubmVjdCBhZnRlciBcIiArIG1heFJlY29ubmVjdEF0dGVtcHRzICsgXCIgXCIgKyBwbHVyYWxpemUoXCJhdHRlbXB0XCIsIG1heFJlY29ubmVjdEF0dGVtcHRzKSArIFwiLiBDbG9zaW5nIHBlcm1hbmVudGx5LlwiO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LkRFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICAgICAgYWxsQ2xlYXJSZXNldFRpbWU6IDUwMDAsXG4gICAgICAgIGNvbm5lY3RUaW1lb3V0OiA1MDAwLFxuICAgICAgICBkZWJ1ZzogZmFsc2UsXG4gICAgICAgIG1pblJlY29ubmVjdERlbGF5OiAxMDAwLFxuICAgICAgICBtYXhSZWNvbm5lY3REZWxheTogMzAwMDAsXG4gICAgICAgIG1heFJlY29ubmVjdEF0dGVtcHRzOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgICAgIHJlY29ubmVjdEJhY2tvZmZGYWN0b3I6IDEuNSxcbiAgICAgICAgc2hvdWxkUmVjb25uZWN0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAgICB3c0NvbnN0cnVjdG9yOiB1bmRlZmluZWQsXG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQuQ09OTkVDVElORyA9IDA7XG4gICAgU3R1cmR5V2ViU29ja2V0Lk9QRU4gPSAxO1xuICAgIFN0dXJkeVdlYlNvY2tldC5DTE9TSU5HID0gMjtcbiAgICBTdHVyZHlXZWJTb2NrZXQuQ0xPU0VEID0gMztcbiAgICByZXR1cm4gU3R1cmR5V2ViU29ja2V0O1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFN0dXJkeVdlYlNvY2tldDtcbmZ1bmN0aW9uIGFwcGx5RGVmYXVsdE9wdGlvbnMob3B0aW9ucykge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhTdHVyZHlXZWJTb2NrZXQuREVGQVVMVF9PUFRJT05TKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gb3B0aW9uc1trZXldO1xuICAgICAgICByZXN1bHRba2V5XSA9XG4gICAgICAgICAgICB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBTdHVyZHlXZWJTb2NrZXQuREVGQVVMVF9PUFRJT05TW2tleV1cbiAgICAgICAgICAgICAgICA6IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXREYXRhQnl0ZUxlbmd0aChkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIC8vIFVURi0xNiBzdHJpbmdzIHVzZSB0d28gYnl0ZXMgcGVyIGNoYXJhY3Rlci5cbiAgICAgICAgcmV0dXJuIDIgKiBkYXRhLmxlbmd0aDtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIHJldHVybiBkYXRhLnNpemU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBsdXJhbGl6ZShzLCBuKSB7XG4gICAgcmV0dXJuIG4gPT09IDEgPyBzIDogcyArIFwic1wiO1xufVxuZnVuY3Rpb24gbm9vcCgpIHtcbiAgICAvLyBOb3RoaW5nLlxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sturdy-websocket/dist/index.js\n");

/***/ })

};
;